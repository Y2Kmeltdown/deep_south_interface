22 serialization::archive 17 0 0 0 0 6 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 0 0 16 0 0 0 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 8 qsys_top 14 PCIe_to_avmm_0 26 altera_avalon_dc_fifo_1940 5 synth 53 PCIe_to_avmm_0_altera_avalon_dc_fifo_1940_j7a573y.sdc 4811 #-------------------------------------------------------------------------------
# TimeQuest constraints to constrain the timing across asynchronous clock domain crossings.
# The idea is to minimize skew to less than one launch clock period to keep the gray encoding, 
# and to minimize latency on the pointer crossings.
#
# The paths are from the Gray Code read and write pointers to their respective synchronizer banks.
#
# *** Important note *** 
#
# Do not declare the FIFO clocks as asynchronous at the top level, or false path these crossings,
# because that will override these constraints.
#-------------------------------------------------------------------------------
set all_dc_fifo [get_entity_instances PCIe_to_avmm_0_altera_avalon_dc_fifo_1940_j7a573y]

set_max_delay -from [get_registers {*|in_wr_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 200
set_min_delay -from [get_registers {*|in_wr_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] -200

set_max_delay -from [get_registers {*|out_rd_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 200
set_min_delay -from [get_registers {*|out_rd_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] -200

set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from [get_pins -compatibility_mode {*|in_wr_ptr_gray[*]*}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 
set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from [get_pins -compatibility_mode {*|out_rd_ptr_gray[*]*}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}]


foreach dc_fifo_inst $all_dc_fifo {
   if { [ llength [query_collection -report -all [get_registers -nowarn $dc_fifo_inst|in_wr_ptr_gray[*]]]] > 0  } {
      set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -from [get_registers $dc_fifo_inst|in_wr_ptr_gray[*]] -to [get_registers $dc_fifo_inst|write_crosser|sync[*].u|din_s1] 
   }

   if { [ llength [query_collection -report -all [get_registers -nowarn $dc_fifo_inst|out_rd_ptr_gray[*]]]] > 0 } {
      set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -from [get_registers $dc_fifo_inst|out_rd_ptr_gray[*]] -to [get_registers $dc_fifo_inst|read_crosser|sync[*].u|din_s1] 
   }
}


# add in timing constraints across asynchronous clock domain crossings for simple dual clock memory inference

set mem_regs [get_registers -nowarn *|PCIe_to_avmm_0_altera_avalon_dc_fifo_1940_j7a573y:*|mem*];
if {![llength [query_collection -report -all $mem_regs]] > 0} {
    set mem_regs [get_registers -nowarn PCIe_to_avmm_0_altera_avalon_dc_fifo_1940_j7a573y:*|mem*];
}

set internal_out_payload_regs [get_registers -nowarn *|PCIe_to_avmm_0_altera_avalon_dc_fifo_1940_j7a573y:*|internal_out_payload*];
if {![llength [query_collection -report -all $internal_out_payload_regs]] > 0} {
    set internal_out_payload_regs [get_registers -nowarn PCIe_to_avmm_0_altera_avalon_dc_fifo_1940_j7a573y:*|internal_out_payload*];
}

if {[llength [query_collection -report -all $internal_out_payload_regs]] > 0 && [llength [query_collection -report -all $mem_regs]] > 0} {
    set_max_delay -from $mem_regs -to $internal_out_payload_regs 200
    set_min_delay -from $mem_regs -to $internal_out_payload_regs -200

    set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from $mem_regs -to $internal_out_payload_regs

    #set_max_skew 2 -from $mem_regs -to $internal_out_payload_regs
}

# -----------------------------------------------------------------------------
# This procedure constrains the skew between the pointer bits, and should
# be called from the top level SDC, once per instance of the FIFO.
#
# The hierarchy path to the FIFO instance is required as an 
# argument.
# -----------------------------------------------------------------------------
proc constrain_altera_avalon_dc_fifo_ptr_skew { path } {

    set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -from [ get_registers $path|in_wr_ptr_gray\[*\] ] -to [ get_registers $path|write_crosser|sync\[*\].u|din_s1 ]
    set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -from [ get_registers $path|out_rd_ptr_gray\[*\] ] -to [ get_registers $path|read_crosser|sync\[*\].u|din_s1 ]

}

 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 8 qsys_top 26 qsys_top_avmm_bridge_512_0 17 altera_iopll_1931 5 synth 56 qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy.sdc 5667 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the timing constraints for the Altera PLL.
#    * The helper routines are defined in qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_pin_map.tcl
#
# NOTE
# ----
# Debug switch. Change to 1 to get more run-time debug information
set debug 0

set script_dir [file dirname [info script]]

source "$script_dir/qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_parameters.tcl"
source "$script_dir/qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_pin_map.tcl"

####################
#                  #
# GENERAL SETTINGS #
#                  #
####################

# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty


# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3

# Determine if entity names are on
set entity_names_on [ ai_are_entity_names_on ]

if {[catch {load_package atoms
            load_package sdc_ext
            load_package design
            catch {read_atom_netlist} read_atom_netlist_out
            set read_atom_netlist_error [regexp "ERROR" $read_atom_netlist_out]
            } err_loading_packages]} {
    post_message -type error "Failed to load packages required by IOPLL SDC: $err_loading_packages"
}

# This is the main call to the netlist traversal routines
# that will automatically find all pins and registers required
# to apply timing constraints.
# During the fitter, the routines will be called only once
# and cached data will be used in all subsequent calls.



if {[info exists ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_ai_pll_db]} {
    # Clean-up stale content
    unset ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_ai_pll_db
}
if {[catch {ai_initialize_pll_db ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_ai_pll_db} err_initializing_db]} {
    post_message -type warning "Failed to find atom information in IOPLL SDC: $err_initializing_db"
}

# If multiple instances of this core are present in the
# design they will all be constrained through the
# following loop
set instances [ array names ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_ai_pll_db ]
foreach { inst } $instances {
	if { [ info exists pins ] } {
		# Clean-up stale content
		unset pins
	}
	
	# -------------------------------- #
	# -                              - #
	# --- Determine PLL Parameters --- #
	# -                              - #
	# -------------------------------- #
	
	set pll_atoms [get_atom_nodes -matching ${inst}* -type IOPLL]
	set num_pll_inst [get_collection_size $pll_atoms]
	
	if {$num_pll_inst > 1} { 
		# Error condition
		post_message -type error "SDC: More than one PLL atom found with instance name $inst"
	} else {
		# Use IP generated parameters
		if { $debug } {
			post_message -type info "SDC: using IP generated parameter values"
		}
	}

    # These dictionaries hold all the clock information.
    lassign $::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_ai_pll_db($inst) base_clock_data_dict gen_clock_data_dict
	
	# ------------------------ #
	# -                      - #
	# ---REFERENCE CLOCK(s)--- #
	# -                      - #
	# ------------------------ #
    dict for {clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_fpga_pin && !$exists} {
               create_clock -period $period \
                   -waveform [ list 0 $half_period] \
                   -name $name $port_node_name
            }
        }
    }
	# ------------------------- #
	# -                       - #
	# --- OUTPUT PLL CLOCKS --- #
	# -                       - #
	# ------------------------- #
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            if {$is_valid && !$exists} {
                create_generated_clock -add \
                    -source $src \
                    -name $name \
                    -multiply_by $multiply_by \
                    -divide_by $divide_by \
                    -phase $phase \
                    -duty_cycle $duty_cycle \
                    $pin_node_name
                
                if {[string match lvds* $clock_key] && [string match *loaden* $pattern] && [dict exists $gen_clock_data_dict $clock_key "through_pin" ] } {  
                    set_max_delay_in_fit_or_false_path_in_sta_through_no_warn $through_pin $max_delay
                } 
            }
        }
    }
}
 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 8 qsys_top 26 qsys_top_avmm_bridge_512_0 17 altera_iopll_1931 5 synth 67 qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_parameters.tcl 6580 # PLL Parameters

#USER W A R N I N G !
#USER The PLL parameters are statically defined in this
#USER file at generation time!
#USER To ensure timing constraints and timing reports are correct, when you make 
#USER any changes to the PLL component using the Qsys,
#USER apply those changes to the PLL parameters in this file

set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy

set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data [dict create]
set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data [dict create]
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk pattern __inst_name__|stratix10_altera_iopll_i|s10_iopll.fourteennm_pll|refclk\[0\]
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk node_type pin
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk pin_id ""
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk pin_node_name ""
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk port_id ""
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk port_node_name ""
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk is_fpga_pin false
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk is_main_refclk true
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk exists false
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk name "__inst_name___refclk"
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk period 2.000
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data refclk half_period 1.000
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock pattern __inst_name__|stratix10_altera_iopll_i|s10_iopll.fourteennm_pll~ncntr_reg
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock node_type register
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock pin_id ""
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock is_valid false
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock exists false
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock name "__inst_name___n_cnt_clk"
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock src refclk
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock multiply_by 1
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock divide_by 2
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock phase 0.000
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data n_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock pattern __inst_name__|stratix10_altera_iopll_i|s10_iopll.fourteennm_pll~mcntr_reg
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock node_type register
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock pin_id ""
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock is_valid false
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock exists false
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock name "__inst_name___m_cnt_clk"
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock src refclk
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock multiply_by 1
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock divide_by 10
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock phase 0.000
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data m_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 pattern __inst_name__|stratix10_altera_iopll_i|s10_iopll.fourteennm_pll|outclk\[0\]
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 node_type pin
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 pin_id ""
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 pin_node_name ""
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 is_valid false
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 exists false
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 name __inst_name___outclk0
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 src refclk
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 multiply_by 5
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 divide_by 5
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 phase 0.000
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 duty_cycle 50
dict set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data outclk0 counter_index 0
 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 8 qsys_top 26 qsys_top_avmm_bridge_512_0 17 altera_iopll_1931 5 synth 64 qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_pin_map.tcl 37555 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the traversal routines that are used by
# qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy.sdc scripts. 
#
# These routines are only meant to support the SDC. 
# Trying to using them in a different context can have unexpected 
# results.

set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_debug 0

set script_dir [file dirname [info script]]

source [file join $script_dir qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_parameters.tcl]

proc get_warnings_disabled {} {
    set local_disable_warnings true
    set inis [split [get_global_assignment -name INI_VARS] ";"]
    foreach ini $inis {
        set ini_lst [split $ini "="]
        lassign $ini_lst ini_name ini_value
        if {$ini_name == "disable_warnings" && $ini_value == "off"} {
            set local_disable_warnings false
            break
        }
    }
    return $local_disable_warnings 
}
set ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_disable_warnings [get_warnings_disabled]

# ----------------------------------------------------------------
#
proc ai_post_message {msg_type msg {msg_context sta_only}} {
#
# Description: Posts a message to Quartus, depending on 
# msg_context (sta_only, all)
#              
#              
#
# ----------------------------------------------------------------

    if {$msg_type == "debug"} {
        if {$::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_debug} {
            puts $msg
        }
    } else {
        if {$msg_context == "all"} {
            post_message -type $msg_type $msg
        } elseif {$msg_context == "sta_only"} {
            if {$::TimeQuestInfo(nameofexecutable) == "quartus_sta"} {
                post_message -type $msg_type $msg
            }
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_are_entity_names_on { } {
#
# Description: Determines if the entity names option is on
#
# ----------------------------------------------------------------
	return [set_project_mode -is_show_entity]	
}

# ----------------------------------------------------------------
#
proc ai_initialize_pll_db { pll_db_par } {
#
# Description: Gets the instances of this particular PLL IP and creates the pin
#              cache
#
# ----------------------------------------------------------------
	upvar $pll_db_par local_pll_db

	global ::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename

	ai_post_message info "Initializing PLL database for CORE $::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename"
	set instance_list [ai_get_core_instance_list $::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename]

	foreach instname $instance_list {
		ai_post_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename INSTANCE: $instname"

		set clock_data_dicts [ai_get_pll_pins $instname]
		lassign $clock_data_dicts base_clock_data_dict gen_clock_data_dict
        print_clock_data $base_clock_data_dict
        print_clock_data $gen_clock_data_dict 

		set local_pll_db($instname) $clock_data_dicts 
	}
}

# ----------------------------------------------------------------
#
proc ai_get_core_instance_list {corename} {
#
# Description: Converts node names from one style to another style
#
# ----------------------------------------------------------------
	set full_instance_list [ai_get_core_full_instance_list $corename]
	set instance_list [list]

	foreach inst $full_instance_list {
		if {[lsearch $instance_list [escape_brackets $inst]] == -1} {
            ai_post_message debug "Found instance:  $inst"
			lappend instance_list $inst
		}
	}
	return $instance_list
}

# ----------------------------------------------------------------
#
proc ai_get_core_full_instance_list {corename} {
#
# Description: Finds the instances of the particular IP by searching through the cells
#
# ----------------------------------------------------------------

	set instance_list [design::get_instances -entity $corename]
                               
	if {[ llength $instance_list ] == 0} {

        if {!$::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_disable_warnings} {
            ai_post_message warning "The auto-constraining script was not able to detect any instance for core < $corename >" all
            ai_post_message warning "Verify the following:"
            ai_post_message warning " The core < $corename > is instantiated within another component (wrapper)" all
            ai_post_message warning " The core is not the top-level of the project" all
        }
	}

	return $instance_list
}
proc ai_get_registers {pattern} {
    if {$::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_disable_warnings} {
        return [get_registers -nowarn -no_duplicates $pattern]
    } else {
        return [get_registers -no_duplicates $pattern]
    }
}
proc ai_get_pins {pattern} {
    if {$::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_corename_disable_warnings} {
        return [get_pins -nowarn -no_duplicates $pattern]
    } else {
        return [get_pins -no_duplicates $pattern]
    }
}
proc ai_get_pin_node_name {pattern} {
    set pin_collection [ai_get_pins $pattern]
    set num_pins [get_collection_size $pin_collection]
    if {$num_pins == 1} {
        foreach_in_collection id $pin_collection {
            set node_name [get_node_info -name $id]	     
            return $node_name
        }
    } 
    return ""
 
}

# ----------------------------------------------------------------
#
proc ai_get_collection_size_from_pattern {pattern} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    set pin_collection [get_pins -no_duplicates $pattern]
    return [get_collection_size $pin_collection]
}

# ----------------------------------------------------------------
#
proc print_clock_data {d} {
#
# Description: Prints clock data dict
#
# ---------------------------------------------------------------- 
    dict for {clock_key info} $d {
        ai_post_message debug "Clock:  $clock_key"
        dict for {key val} $info {
            ai_post_message debug "   $key: $val"
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_subst_instname {clock_data_dict patt} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            regsub -all "__inst_name__" $name $patt new_name
            regsub -all "__inst_name__" $pattern $patt new_pattern
            
            dict set clock_data_dict $clock_key name $new_name
            dict set clock_data_dict $clock_key pattern $new_pattern
            
            if {[dict exists $clock_data_dict $clock_key "through_pin" ]} {
                regsub -all "__inst_name__" $through_pin $patt new_through_pin
                dict set clock_data_dict $clock_key through_pin $new_through_pin
            }
        }
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_update_genclk_div_mult {clock_data_dict pll_parameters_dict} {
#
# Description: Updates the dict with div/mult values collected from
# the PLL's atom parameters.
#
# ----------------------------------------------------------------
    set compensated_counter_div 0
    set clock_to_compensate [dict get $pll_parameters_dict clock_to_compensate]
    # Loop over dict to find the compensated counter's div value first.
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {[info exists counter_index]} { 
                if {$counter_index == $clock_to_compensate} {
                    set compensated_counter_div [dict get $pll_parameters_dict c${counter_index}_total]
                }
            }
        }
        unset -nocomplain counter_index
    }
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Getting div/mult factors for clock $clock_key" 

            set ccnt -1
            if {[info exists counter_index]} {
                set ccnt [dict get $pll_parameters_dict c${counter_index}_total]
			    set ccnt_dc [dict get $pll_parameters_dict duty_cycle${counter_index}]
            } else {
                set counter_index -1
			    set ccnt_dc 50
            }
            set mult_div [ai_get_mult_div_factors \
                $clock_key \
                $src \
                [dict get $pll_parameters_dict n_total] \
                [dict get $pll_parameters_dict m_total] \
                $ccnt \
                $counter_index \
                $compensated_counter_div \
                [dict get $pll_parameters_dict compensation_mode] \
                [dict get $pll_parameters_dict clock_to_compensate]]

            lassign $mult_div mult div

            ai_post_message debug "Setting mult_div factors for: $clock_key to $mult/$div"

            dict set clock_data_dict $clock_key multiply_by $mult
            dict set clock_data_dict $clock_key divide_by $div
            dict set clock_data_dict $clock_key duty_cycle $ccnt_dc
        }
        unset -nocomplain counter_index
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_set_genclk_pin_info {clock_data_dict} {
#
# Description: Updates the dict with pin info collected from making
# STA API calls.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            if {$node_type == "register"} {
                set pin_collection [ai_get_registers $pattern]
            } elseif {$node_type == "pin"} {
                set pin_collection [ai_get_pins $pattern]
            } else {
                ai_post_message "debug" "Incorrect type of node."
            }
            set num_pins [get_collection_size $pin_collection]
            if {$num_pins == 1} {
                # Always set valid to true if we found the pin node
                ai_post_message debug "Setting clock as valid."
                dict set clock_data_dict $clock_key is_valid true
                
                # This for loop should only loop once.
                foreach_in_collection id $pin_collection {
                    set node_name [get_node_info -name $id]	     
                    dict set clock_data_dict $clock_key pin_id $id
                    dict set clock_data_dict $clock_key pin_node_name $node_name
                }
                # Check if clock_exists, if it does, then
                # set key "exists" on the clock info dict.
                dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

            
            } else {
                dict set clock_data_dict $clock_key is_valid false
            }

        }
    }
    return $clock_data_dict
    
    
} 
# ----------------------------------------------------------------
#
proc ai_set_baseclk_pin_info {clock_data_dict refclk_data_dict} {
#
    # Description: Updates the dict with pin info collected from refclk data
    # dict, which was obtained by traversing netlist.
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_set_baseclk_pin_info"

    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            
            # For each clock in refclk dict, find the one whose pin name
            # matches the pattern in baseclk dict. WE need to do this since
            # we dont find refclk nodes with patterns, but rather by traversal
            # of netlist from outclk backwards.
            
            set node_name ""
            dict for {clock_id info} $refclk_data_dict {
                dict with info {
                    ai_post_message debug "Comparing pattern $pattern with refclock: $ref_pin_node_name"
                    if {[string equal -nocase $pattern $ref_pin_node_name]} {
                        dict set clock_data_dict $clock_key pin_id $ref_pin_id
                        dict set clock_data_dict $clock_key pin_node_name $ref_pin_node_name
                        dict set clock_data_dict $clock_key port_id $ref_port_id
                        dict set clock_data_dict $clock_key port_node_name $ref_port_node_name
                        dict set clock_data_dict $clock_key is_fpga_pin $ref_is_fpga_pin
                        set node_name $ref_port_node_name
                        break
                    }
                }
            }
            # Check if clock_exists, if it does, then
            # set key "exists" on the clock info dict.
            dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

        }
    }
    return $clock_data_dict
    
}
proc ai_get_n_cnt_clock_node_name {gen_clock_data_dict} {
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Clock:  $clock_key, pin_node_name: $pin_node_name"

            if {$clock_key == "n_cnt_clock"} {
                return $pin_node_name
            }
        }
    }
    return ""
}

# ----------------------------------------------------------------
#
proc ai_update_baseclk_data {base_clock_data_dict pll_parameters_dict} {
#
    # Description: Updates the refclk information based on atom settings
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_baseclk_data_dict"

    dict for {base_clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_main_refclk} {
                set ref_period [dict get $pll_parameters_dict refclk_period]
                set ref_period [expr round($ref_period * 1000.0)/1000.0] 
                set ref_period [format %.3f $ref_period]
                dict set base_clock_data_dict $base_clock_key period $ref_period

                set half_period [expr $ref_period /2]
                set half_period [expr round($half_period * 1000.0)/1000.0] 
                set half_period [format %.3f $half_period]
                dict set base_clock_data_dict $base_clock_key half_period $half_period
            }
        }
    }

    return $base_clock_data_dict
}

# ----------------------------------------------------------------
#
proc ai_update_genclk_sources {base_clock_data_dict gen_clock_data_dict pll_parameters_dict} {
#
    # Description: Updates the genclk data dict with src nodes from the appropriate
    # refclks
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_genclk_sources"

    # Check if vcoph pin exists, if it does then set the clock source
    # as vcoph otherwise set it to either refclk or n_cnt_clock
    set vcoph_exists false
    if {[dict exists $gen_clock_data_dict vcoph]} {
        set vcoph_pin_name [ai_get_pin_node_name [dict get $gen_clock_data_dict vcoph pattern]]
        if {$vcoph_pin_name != ""} {
            ai_post_message debug "vcoph pin name: $vcoph_pin_name "
            set vcoph_exists true
        }
    }

    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Setting src pin info for clock $clock_key"

            set node_name ""
            set main_refclk_key ""
            dict for {base_clock_key info} $base_clock_data_dict {
                dict with info {
                    if {$is_main_refclk} {
                        set main_refclk_key $base_clock_key
                        if {$is_fpga_pin} {
                            set node_name $port_node_name
                        } else {
                            set node_name $pin_node_name
                        }
                        break
                    }
                }
            }
 
            if {$clock_key != "n_cnt_clock" && ![dict get $pll_parameters_dict n_bypass]} {
                set src "n_cnt_clock"
            }

            if {$src == "refclk" || $src == "cascade_in"} {
                set src_ $node_name
            } elseif {$src == "n_cnt_clock"} {
                set src_ [ai_get_n_cnt_clock_node_name $gen_clock_data_dict]
            } else {
                set src_ "" 
                ai_post_message "warning" "Undefined clock source: $src"

                dict set gen_clock_data_dict $clock_key is_valid false 
            }

            if {$clock_key != "n_cnt_clock" && $clock_key != "vcoph" && $vcoph_exists} {
                set src_ $vcoph_pin_name
            }

            dict set gen_clock_data_dict $clock_key src $src_
        }
    }
    return $gen_clock_data_dict 
    
}
proc ai_invalidate_clocks {clock_data_dict} {
    # Set the is_valid flag on each clock to false
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            dict set clock_data_dict $clock_key is_valid false
        }
    }
    return $clock_data_dict
}
proc ai_get_first_outclk_node {clock_data_dict} {
    set outclk_pin_id "None"
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {$node_type == "pin" && $is_valid} {
                set outclk_pin_id $pin_id
                break
            }
        }
    }
    if {$outclk_pin_id == "None"} {
        ai_post_message "warning" "Could not find any valid outclks"
    }
    return $outclk_pin_id 
}
# ----------------------------------------------------------------
#
proc ai_get_pll_pins { instname } {
#
# Description: Stores the pins of interest for the instance of the IP
#
# ----------------------------------------------------------------

    set base_clock_data_dict $::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_base_clock_data
    set gen_clock_data_dict $::GLOBAL_top_qsys_top_avmm_bridge_512_0_altera_iopll_1931_p2t7wuy_gen_clock_data
    # First regsub the instance name for the pin names and patterns.
    set base_clock_data_dict [ai_subst_instname $base_clock_data_dict $instname]
    set gen_clock_data_dict [ai_subst_instname $gen_clock_data_dict $instname]


    set pll_parameters_dict [ai_get_pll_atom_parameters $instname] 
    set gen_clock_data_dict [ai_set_genclk_pin_info $gen_clock_data_dict]

    ai_post_message debug "gen_clock_data_dict initial: "
    print_clock_data $gen_clock_data_dict 
    
    # Traverse the first generated clock back to find FPGA pins for refclks.
    set outclk_node_id [ai_get_first_outclk_node $gen_clock_data_dict]
    if {$outclk_node_id != "None"} {
        set refclk_data_dict [ai_get_input_clk_info $outclk_node_id]
        ai_post_message debug "refclk_data_dict: "
        print_clock_data $refclk_data_dict

        set base_clock_data_dict [ai_set_baseclk_pin_info $base_clock_data_dict $refclk_data_dict]
        set gen_clock_data_dict [ai_update_genclk_sources $base_clock_data_dict $gen_clock_data_dict $pll_parameters_dict]
        set gen_clock_data_dict [ai_update_genclk_div_mult $gen_clock_data_dict $pll_parameters_dict] 
        set base_clock_data_dict [ai_update_baseclk_data $base_clock_data_dict $pll_parameters_dict] 
        ai_post_message debug "base_clock_data_dict: "
        print_clock_data $base_clock_data_dict 
        ai_post_message debug "gen_clock_data_dict final: "
        print_clock_data $gen_clock_data_dict
    } else {
        # Make sure that we don't create any clock constraints
        # if no output clock was found
        set gen_clock_data_dict [ai_invalidate_clocks $gen_clock_data_dict]
    }
    
    return [list $base_clock_data_dict $gen_clock_data_dict]
    
}

# ----------------------------------------------------------------
#
proc ai_get_input_clk_info { outclk_pin_id } {
#
# Description: Searches back from the output of the PLL to find the reference clock pin.
#              If the reference clock is fed by an input buffer, it finds that pin, otherwise
#              in cascading modes it will return the immediate reference clock input of the PLL.
#
# ----------------------------------------------------------------
	if {[ai_is_node_type_pll_clk $outclk_pin_id]} {
        #stores the refclk pin ids that were found by tracing the 
        #output clocks back up
		array set refclk_array [list]
		ai_traverse_fanin_up_to_depth $outclk_pin_id ai_is_node_type_pll_inclk clock refclk_array 20
        array set refclk_info_array [list]
        foreach {net_id id} [array get refclk_array] {
            set net_name [get_node_info -name $net_id]
            set refclk_info_array($net_id) $net_name

        }
        # Dict to hold the refclk info found by traversing the netlist back.
        # refclk_data = {
        #   clock_id = {
        #       ref_pin_id: str,
        #       ref_pin_node_name: str,
        #       ref_port_id: str,
        #       ref_port_node_name: str,
        #       ref_is_fpga_pin: true/false,
        #   }
        # }
        set refclk_data [dict create]
        
        set clock_id 0

        #only works if there is either 1 or 2 refclks
		if {[array size refclk_array] == 1 || [array size refclk_array] == 2} {
            #iterate over each refclk pin and trace back to find its input port
            foreach refclk_pin_id [array names refclk_info_array] {
                array set user_refclk_array [list]
                array unset refclk_array
                array unset user_refclk_array [list]
					 
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_user_clock clock user_refclk_array 5
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_pin clock refclk_array 5
					 
                # If fed by any user specified clock (which could be specified at the pin level or at the
                # buffer level), then use that pin as the source.
                # Otherwise, trace back to the dedicated input pin (depth 5 so that we don't include global clocks)
                if {[array size user_refclk_array] == 1 || [array size refclk_array] < 1} {
                    # Fed by a user specified clock, a global clock etc. 
                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id ""
                    dict set refclk_data $clock_id ref_port_node_name ""
                    dict set refclk_data $clock_id ref_is_fpga_pin false
                } else {
                    # Fed by a dedicated input pin
                    set port_id_ [lindex [array names refclk_array] 0]

                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id $port_id_
                    dict set refclk_data $clock_id ref_port_node_name [get_node_info -name $port_id_]
                    dict set refclk_data $clock_id ref_is_fpga_pin true
                }

                incr clock_id
            }
        } else {
			ai_post_message critical_warning "Could not find PLL ref clock that feeds [get_node_info -name $outclk_pin_id]" all
		}
	} else {
		ai_post_message error "Internal error: ai_get_input_clk_info only works for PLL output clocks" all
	}
	return $refclk_data
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pin { node_id } {
#
# Description: Determines if a node is a top-level port of the FPGA
#
# ----------------------------------------------------------------

	set node_type [get_node_info -type $node_id]
	if {$node_type == "port"} {
		set result 1
	} else {
		set result 0
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_user_clock { node_id } {
#
# Description: Determines if a node is a user-defined clock
#
# ----------------------------------------------------------------
    set node_name [get_node_info -name $node_id]	 
   
    if {[ai_clock_exists $node_name]} {
        return 1
    } else {
        return 0
    }
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_clk { node_id } {
#
# Description: Determines if a node is an output of a PLL
#
# ----------------------------------------------------------------

	set cell_id [get_node_info -cell $node_id]
	
	if {$cell_id == ""} {
		set result 0
	} else {
		set atom_type [get_cell_info -atom_type $cell_id]
		if {$atom_type == "IOPLL"} {
			set node_name [get_node_info -name $node_id]
            ai_post_message debug "Node_name: $node_name"
			if {[string match "*fourteennm_pll\|outclk\\\[*\\\]" $node_name]||[string match "*tennm_pll\|outclk\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll~ncntr_reg" $node_name]||[string match "*tennm_pll~ncntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll~c*cntr_reg" $node_name]||[string match "*tennm_pll~c*cntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll~mcntr_reg" $node_name]||[string match "*tennm_pll~mcntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll\|lvds_clk\\\[*\\\]" $node_name]||[string match "*tennm_pll\|lvds_clk\\\[*\\\]" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll\|loaden\\\[*\\\]" $node_name]||[string match "*tennm_pll\|loaden\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|vcoph\\\[*\\\]" $node_name]||[string match "*tennm_pll\|vcoph\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|pll_cascade_out" $node_name]||[string match "*tennm_pll\|pll_cascade_out" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|extclk_output\\\[*\\\]" $node_name]||[string match "*tennm_pll\|extclk_output\\\[*\\\]" $node_name]} {
				set result 1
			} else {
				set result 0
			}
		} else {
			set result 0
		}
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_inclk { node_id } {
#
# Description: Determines if a node is an input of a PLL
#
# ----------------------------------------------------------------


	set cell_id [get_node_info -cell $node_id]
	
	if {$cell_id == ""} {
		set result 0
	} else {
		set atom_type [get_cell_info -atom_type $cell_id]
		if {$atom_type == "IOPLL"} {
			set node_name [get_node_info -name $node_id]
			set fanin_edges [get_node_info -clock_edges $node_id]
			if {([string match "*|refclk\\\[*\\\]" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
            } elseif {([string match "*|pll_cascade_in" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
			} else {
				set result 0
			}
		} else {
			set result 0
		}
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
#
# Description: General traversal function up until a depth.  Use a function pointer to decide
#              ending conditions.
#
# ----------------------------------------------------------------

	upvar 1 $results_array_name results
	
	if {$depth < 0} {
		error "Internal error: Bad timing netlist search depth"
	}
	set fanin_edges [get_node_info -${edge_type}_edges $node_id]
	set number_of_fanin_edges [llength $fanin_edges]
	for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
		set fanin_edge [lindex $fanin_edges $i]
		set fanin_id [get_edge_info -src $fanin_edge]
		if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
			set results($fanin_id) 1
		} elseif {$depth == 0} {
		} else {
			ai_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
		}
	}
}

# ----------------------------------------------------------------
#
proc ai_index_in_collection { col j } {
#
# Description: Returns a particular index in a collection.
#              Analagous to lindex for lists.
#
# ----------------------------------------------------------------

	set i 0
	foreach_in_collection path $col {
		if {$i == $j} {
			return $path
		}
		set i [expr $i + 1]
	}
	return ""
}

#
# Description: Rounds a given floating point number
#              to 3 decimal places
#
# ----------------------------------------------------------------
proc ai_round_3dp { x } {
    return [expr { round($x * 1000) / 1000.0  } ]
}

# ----------------------------------------------------------------
# Description: Checks whether a given clock already exists 
# ----------------------------------------------------------------
proc ai_clock_exists { clock_name } {
    set clock_found false
    set input_clocks_col [get_clocks -nowarn]
    set num_input_clocks [get_collection_size $input_clocks_col]
    
    if {$num_input_clocks > 0} {
        foreach_in_collection iclk $input_clocks_col {
            if {![is_clock_defined $iclk]} {
                continue
            }

            set clk_targets_col [get_clock_info -target $iclk]
            set num_clk_targets [get_collection_size $clk_targets_col]
            if {$num_clk_targets > 0} {
                foreach_in_collection itgt $clk_targets_col {
                    set node_name [get_node_info -name $itgt]
                    if {[string compare $node_name $clock_name] == 0} {
                        set clock_found true
                        break
                    }
                }
            }
            if {$clock_found == true} {
                break;
            }
        }
    }

   return $clock_found 
}

proc ai_get_pll_atom {instname} {
    foreach_in_collection node [get_atom_nodes -type IOPLL] {
        set name [get_atom_node_info -key NAME -node $node]
        set node_list($name) $node

        if {[string first $instname $name] > -1} {
            return $node
        }
    }
    set sdc_file_name [info script]
    ai_post_message warning "Could not find IOPLL atom with the name <$instname> while processing <$sdc_file_name>. Please check the synthesis report to ensure that the IOPLL was not synthesized away." all
}
proc ai_get_mult_div_factors {clock_key src ncnt mcnt ccnt counter_index \
                              compensated_counter_div compensation_mode \
                              clock_to_compensate} {
    if {$clock_key == "vcoph"} {
        set clock_mult $mcnt
        set clock_div 1
    } elseif {$clock_key == "n_cnt_clock"} {
        set clock_mult 1
        set clock_div $ncnt
    } elseif {$clock_key == "m_cnt_clock"} {
        set clock_mult 1
        set clock_div [expr {$mcnt * $ncnt}]
    } else {

        if {[string first "vcoph" $src] > -1} {
            set clock_mult 1
            set clock_div $ccnt
        } else {
            # Handle NDFB mode. 
            # The equation for counter which is to be compensated: C_k = M / N
            # The equation for all other counters:                 C_!k = (M * C_k) / (N * C_!k)
            if {$compensation_mode == "NON_DEDICATED_SOURCE_SYNC" || $compensation_mode == "NON_DEDICATED_NORMAL"} {
                if {$counter_index == $clock_to_compensate} {
                    set clock_mult $mcnt
                    # Instead of dividing by N, we just divide by 1
                    # since a clock based on the N counter would be created
                    # if N > 1 and this clock would be derived based on that,
                    # so we already have a division happening.
                    set clock_div 1
                } else {
                    set clock_mult [expr $mcnt * $compensated_counter_div]
                    set clock_div $ccnt
                }
            } else {
                ai_post_message debug "Normal C counter"
                set clock_mult $mcnt
                set clock_div $ccnt
            }
        }
    }
    return [list $clock_mult $clock_div]

}
# ----------------------------------------------------------------
#
proc ai_get_pll_atom_parameters {instname} {
#
# Description: Gets the PLL paramaters from the Quartus atom and not 
#              from the IP generated parameters.
#
# ----------------------------------------------------------------

    set pll_atom [ai_get_pll_atom $instname]
																			 
	dict set pll_params compensation_mode [get_atom_node_info -key ENUM_IOPLL_FEEDBACK -node $pll_atom]
	dict set pll_params clock_to_compensate [get_atom_node_info -key INT_IOPLL_CLOCK_TO_COMPENSATE -node $pll_atom]

    # Get refclk frequency (might have changed since IP generation)
    set refclk_freq [get_atom_node_info -key TIME_REFERENCE_CLOCK_FREQUENCY -node $pll_atom]
    set refclk_int [string trim $refclk_freq "*MHZmhz"]
    set refclk_period [expr 1000.0 / $refclk_int]
    dict set pll_params refclk_period $refclk_period

	dict set pll_params m_hi_div [get_atom_node_info -key INT_IOPLL_M_CNT_HI_DIV -node $pll_atom]
	dict set pll_params m_lo_div [get_atom_node_info -key INT_IOPLL_M_CNT_LO_DIV -node $pll_atom]
	dict set pll_params m_bypass [get_atom_node_info -key BOOL_IOPLL_M_CNT_BYPASS_EN -node $pll_atom]
    if {[dict get $pll_params m_bypass]} {
        set total 1
    } else {
        set total  [expr [dict get $pll_params m_hi_div] + [dict get $pll_params m_lo_div]]
    }
	dict set pll_params m_total $total

	dict set pll_params n_hi_div [get_atom_node_info -key INT_IOPLL_N_CNT_HI_DIV -node $pll_atom]
	dict set pll_params n_lo_div [get_atom_node_info -key INT_IOPLL_N_CNT_LO_DIV -node $pll_atom]
	dict set pll_params n_bypass [get_atom_node_info -key BOOL_IOPLL_N_CNT_BYPASS_EN -node $pll_atom]
    if {[dict get $pll_params n_bypass]} {
        set total 1
    } else {
        set total  [expr [dict get $pll_params n_hi_div] + [dict get $pll_params n_lo_div]]
    }
	dict set pll_params n_total $total

	for { set i 0 } { $i < 9} { incr i } {
        # Get the C counter parameter settings from the atom netlist
        dict set pll_params c${i}_hi_div [get_atom_node_info -key INT_IOPLL_C_CNT_${i}_HI_DIV -node $pll_atom]
        dict set pll_params c${i}_lo_div [get_atom_node_info -key INT_IOPLL_C_CNT_${i}_LO_DIV -node $pll_atom]
        dict set pll_params c${i}_bypass [get_atom_node_info -key BOOL_IOPLL_C_CNT_${i}_BYPASS_EN -node $pll_atom]
        dict set pll_params c${i}_odd_div_duty_en [get_atom_node_info -key BOOL_IOPLL_C_CNT_${i}_EVEN_DUTY_EN -node $pll_atom]

        # Calculate the total counter value
        if {[dict get $pll_params c${i}_bypass]} {
            set total 1
        } else {
            set total [expr [dict get $pll_params c${i}_hi_div] + [dict get $pll_params c${i}_lo_div]]
        }
        dict set pll_params c${i}_total $total

        # Calculate the duty cycle
        if {[dict get $pll_params c${i}_bypass]} {
            set total_duty 50
        } else {
            if {[dict get $pll_params c${i}_odd_div_duty_en]} {
                set duty_tweak 1
            } else {
                set duty_tweak 0
            }
            set total_duty [expr (([dict get $pll_params c${i}_hi_div] - (0.5*$duty_tweak))*100)/$total]
		    set total_duty [format %.3f $total_duty]
        }
        dict set pll_params duty_cycle${i} $total_duty
    }

    return $pll_params
}

#__ACDS_USER_COMMENT__Set max delay if in fit flow, otherwise set false path through "through_pin"
# originally in the LVDS SDC. This is called if we are exporting loaden to LVDS
proc set_max_delay_in_fit_or_false_path_in_sta_through_no_warn {through_pin delay} {

    set through_pin_collection [get_pins -compatibility_mode -nowarn $through_pin]
    if {[get_collection_size $through_pin_collection] <= 0} { return }
    
    # if fit_flow == 1
    if {$::TimeQuestInfo(nameofexecutable) == "quartus_fit" } { 
        set_max_delay -through $through_pin_collection $delay
    } else { 
        set_false_path -through $through_pin_collection
    } 
} 

 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 8 qsys_top 26 qsys_top_avmm_bridge_512_0 35 altera_xcvr_pcie_hip_native_s10_191 5 synth 74 qsys_top_avmm_bridge_512_0_altera_xcvr_pcie_hip_native_s10_191_xndluca.sdc 51703 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


if {[info exists clk_source_freq]} {
  unset clk_source_freq
}

if {[info exists multiply_factor_dict] } {
  unset multiply_factor_dict
}
set multiply_factor_dict [dict create]

if {[info exists divide_factor_dict] } {
  unset divide_factor_dict
}
set divide_factor_dict [dict create]

set clk_source_freq "250.0 MHz"

set datarate_100m  80

# 250M for aibx2 clocks if BW less or equal 32G
if { [expr $datarate_100m * 16] <= 320 }  {
  dict set multiply_factor_dict aib_internal_div 1
  dict set divide_factor_dict   aib_internal_div 1
  dict set multiply_factor_dict clkout 1
  dict set divide_factor_dict   clkout 2

# 500M for  aibx2 clocks if BW less or equal 64G
} elseif { [expr $datarate_100m * 16] <= 640 }  {
  dict set multiply_factor_dict aib_internal_div 2
  dict set divide_factor_dict   aib_internal_div 1
  dict set multiply_factor_dict clkout 1
  dict set divide_factor_dict   clkout 1

# 1000M for  aibx2 clocks if BW is 128G
} else {
  dict set multiply_factor_dict aib_internal_div 4
  dict set divide_factor_dict   aib_internal_div 1
  dict set multiply_factor_dict clkout 2
  dict set divide_factor_dict   clkout 1
}


# Get the current Native PCIe IP instance
set inst [get_current_instance]

# Check the tile type
set native_phy_tile_nodes ""
set pcie_tile_type H-Tile
if {$pcie_tile_type == "L-Tile"} {
  set native_phy_tile_nodes "ct1_xcvr_native_inst|ct1_xcvr_native_inst|inst_ct1_xcvr_channel"
} else {
  set native_phy_tile_nodes "ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst"
}

# Delete the clock names array if it exists 
if [info exists all_clocks_names] {
  unset all_clocks_names
}
set all_clocks_names [dict create]

#--------------------------------------------- #
#---                                       --- #
#--- CREATE PCIe CLOCKS                    --- #
#---                                       --- #
#--------------------------------------------- #
for { set channels 0 } { $channels < 16 } { incr channels } {

  # ----------------------------------------------------------------------------- #
  # --- Create TX mode clocks and clock frequencies                           --- #
  # ----------------------------------------------------------------------------- #
  set aib_tx_clk_source_nodes  [get_nodes     -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_clk_source]
  set aib_tx_internal_div_regs [get_registers -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_internal_div.reg]

  if {[get_collection_size $aib_tx_clk_source_nodes] > 0 && [get_collection_size $aib_tx_internal_div_regs] > 0} {

    # -------------------------------------------------------------------------------
    # AIB TX CLK SOURCE - PMA parallel clock
    # -------------------------------------------------------------------------------
    foreach_in_collection tx_clk_source $aib_tx_clk_source_nodes {

      # Remove the instance name from the clock source node due to auto promotion in SDC_ENTITY
      set no_inst_tx_clk_source [string replace [get_node_info -name $tx_clk_source] 0 [string length $inst]]

      # Create the TX PMA parallel clock name
      set tx_clk_source_name $inst|tx_pma_parallel_clk|ch${channels}

      create_clock \
        -name $tx_clk_source_name \
        -period $clk_source_freq \
        $no_inst_tx_clk_source -add

      dict lappend all_clocks_names tx_source_clks $tx_clk_source_name

      # -------------------------------------------------------------------------------
      # AIB TX INTERNAL DIV REG - transfer clock
      # -------------------------------------------------------------------------------
      foreach_in_collection tx_internal_div_reg $aib_tx_internal_div_regs {

        # Remove the instance name from the internal div reg node due to auto promotion in SDC_ENTITY
        set no_inst_tx_internal_div_reg [string replace [get_node_info -name $tx_internal_div_reg] 0 [string length $inst]]

        # Create the TX PCS x2 clock name
        set tx_internal_div_reg_name $inst|tx_pcs_x2_clk|ch${channels}

        create_generated_clock \
          -name $tx_internal_div_reg_name \
          -source $no_inst_tx_clk_source \
          -master_clock $tx_clk_source_name \
          -multiply_by [dict get $multiply_factor_dict aib_internal_div] \
          -divide_by   [dict get $divide_factor_dict   aib_internal_div] \
          $no_inst_tx_internal_div_reg -add

        # -------------------------------------------------------------------------------
        # TX CLKOUT
        # -------------------------------------------------------------------------------
        set pld_pcs_tx_clkout_pins [get_pins -nowarn -compat altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_pcs_tx_clk_out1_dcm]

        if {[get_collection_size $pld_pcs_tx_clkout_pins] > 0} {

          foreach_in_collection tx_clkout $pld_pcs_tx_clkout_pins {

            # Remove the instance name from the output clock node due to auto promotion in SDC_ENTITY
            set no_inst_tx_clkout [string replace [get_node_info -name $tx_clkout] 0 [string length $inst]]

            create_generated_clock \
              -name  $inst|xcvr_hip_native|ch${channels} \
              -source $no_inst_tx_clk_source \
              -master_clock $tx_clk_source_name \
              -multiply_by [dict get $multiply_factor_dict clkout] \
              -divide_by   [dict get $divide_factor_dict   clkout] \
              $no_inst_tx_clkout -add
          }
        }
      }; # foreach in collection aib_tx_internal_div_regs
    }; # foreach in collection aib_tx_clk_source_nodes
  }; # if get_collection_size aib_tx_clk_source_nodes && aib_tx_internal_div_regs


  # ----------------------------------------------------------------------------- #
  # --- Create RX mode clocks and clock frequencies                           --- #
  # ----------------------------------------------------------------------------- #
  set aib_rx_clk_source_nodes  [get_nodes -nowarn     altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_rx_clk_source]
  set aib_rx_internal_div_regs [get_registers -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_rx_internal_div.reg]

  if {[get_collection_size $aib_rx_clk_source_nodes] > 0 && [get_collection_size $aib_rx_internal_div_regs] > 0} {

    # -------------------------------------------------------------------------------
    # AIB RX CLK SOURCE - PMA parallel clock
    # -------------------------------------------------------------------------------
    foreach_in_collection rx_clk_source $aib_rx_clk_source_nodes {

      # Remove the instance name from the clock source node due to auto promotion in SDC_ENTITY
      set no_inst_rx_clk_source [string replace [get_node_info -name $rx_clk_source] 0 [string length $inst]]

      # Create the RX PMA parallel clock name
      set rx_clk_source_name $inst|rx_pma_parallel_clk|ch${channels}

      create_clock \
        -name $rx_clk_source_name \
        -period $clk_source_freq \
        $no_inst_rx_clk_source -add

      dict lappend all_clocks_names rx_source_clks $rx_clk_source_name

      # -------------------------------------------------------------------------------
      # AIB RX INTERNAL DIV REG - transfer clock
      # -------------------------------------------------------------------------------
      foreach_in_collection rx_internal_div_reg $aib_rx_internal_div_regs {

        # Remove the instance name from the internal div reg node due to auto promotion in SDC_ENTITY
        set no_inst_rx_internal_div_reg [string replace [get_node_info -name $rx_internal_div_reg] 0 [string length $inst]]

        # Create the rX PCS x2 clock name
        set rx_internal_div_reg_name $inst|rx_pcs_x2_clk|ch${channels}

        create_generated_clock \
          -name $rx_internal_div_reg_name \
          -source $no_inst_rx_clk_source \
          -master_clock $rx_clk_source_name \
          -multiply_by [dict get $multiply_factor_dict aib_internal_div] \
          -divide_by   [dict get $divide_factor_dict   aib_internal_div] \
          $no_inst_rx_internal_div_reg -add

        # -------------------------------------------------------------------------------
        # RX CLKOUT
        # -------------------------------------------------------------------------------
        set pld_pcs_rx_clkout_pins [get_pins -nowarn -compat altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_pcs_rx_clk_out1_dcm]

        if {[get_collection_size $pld_pcs_rx_clkout_pins] > 0} {

          foreach_in_collection rx_clkout $pld_pcs_rx_clkout_pins {

            # Remove the instance name from the output clock node due to auto promotion in SDC_ENTITY
            set no_inst_rx_clkout [string replace [get_node_info -name $rx_clkout] 0 [string length $inst]]

            create_generated_clock \
              -name  $inst|xcvr_hip_native|ch${channels} \
              -source $no_inst_rx_clk_source \
              -master_clock $rx_clk_source_name \
              -multiply_by [dict get $multiply_factor_dict clkout] \
              -divide_by   [dict get $divide_factor_dict   clkout] \
              $no_inst_rx_clkout -add
          }
        }
      }; #foreach in collection aib_rx_internal_div_regs
    }; # foreach in collection aib_rx_clk_source_nodes
  }; # if get_collection_size aib_rx_clk_source_nodes && aib_rx_internal_div_regs


  #--------------------------------------------- #
  #---                                       --- #
  #--- MIN & MAX DELAYS FOR RESETS           --- #
  #---                                       --- #
  #--------------------------------------------- #
  set rx_digital_aib_reset_reg   [get_registers -nowarn    altera_xcvr_pcie_hip_native_rx_aib_reset_seq|aib_reset_out_stage*]
  set rx_pld_adapter_reset_atom  [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_adapter_rx_pld_rst_n]
  set rx_pld_adapter_reset_pins  [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_adapter_rx_pld_rst_n*]
  set rx_pld_dll_lock_req_atom   [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_rx_dll_lock_req]
  set rx_pld_dll_lock_req_pins   [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|pld_rx_dll_lock_req*]

  if {[get_collection_size $rx_digital_aib_reset_reg] > 0 && [get_collection_size $rx_pld_adapter_reset_atom] > 0} {
    set_max_delay -from $rx_digital_aib_reset_reg -through $rx_pld_adapter_reset_atom 200
    set_min_delay -from $rx_digital_aib_reset_reg -through $rx_pld_adapter_reset_atom -5
  }

  if {[get_collection_size $rx_digital_aib_reset_reg] > 0 && [get_collection_size $rx_pld_dll_lock_req_atom] > 0 && [get_collection_size $rx_pld_dll_lock_req_pins] > 0} {
    set_max_delay -from $rx_digital_aib_reset_reg -through $rx_pld_dll_lock_req_atom -to $rx_pld_dll_lock_req_pins 200
    set_min_delay -from $rx_digital_aib_reset_reg -through $rx_pld_dll_lock_req_atom -to $rx_pld_dll_lock_req_pins -5
  }

  set tx_digital_aib_reset_reg   [get_registers -nowarn    altera_xcvr_pcie_hip_native_tx_aib_reset_seq|aib_reset_out_stage*]
  set tx_pld_adapter_reset_atom  [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n]
  set tx_pld_adapter_reset_pins  [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n*]
  set tx_pld_dll_lock_req_atom   [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_dll_lock_req]
  set tx_pld_dll_lock_req_pins   [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_dll_lock_req*]

  if {[get_collection_size $tx_digital_aib_reset_reg] > 0 && [get_collection_size $tx_pld_adapter_reset_atom] > 0} {
    set_max_delay -from $tx_digital_aib_reset_reg -through $tx_pld_adapter_reset_atom 200
    set_min_delay -from $tx_digital_aib_reset_reg -through $tx_pld_adapter_reset_atom -5
  }

  if {[get_collection_size $tx_digital_aib_reset_reg] > 0 && [get_collection_size $tx_pld_dll_lock_req_atom] > 0 && [get_collection_size $tx_pld_dll_lock_req_pins] > 0} {
    set_max_delay -from $tx_digital_aib_reset_reg -through $tx_pld_dll_lock_req_atom -to $tx_pld_dll_lock_req_pins 200
    set_min_delay -from $tx_digital_aib_reset_reg -through $tx_pld_dll_lock_req_atom -to $tx_pld_dll_lock_req_pins -5
  }

  #-------------------------------------------------- #
  #---                                            --- #
  #--- Internal loopback path                     --- #
  #---                                            --- #
  #-------------------------------------------------- #
  set pld_tx_clk2_dcm_reg_col        [get_registers    -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~pld_tx_clk2_dcm.reg]
  set aib_fabric_tx_data_lpbk_col    [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx*aib_fabric_tx_data_lpbk*]
  set aib_fabric_rx_transfer_clk_col [get_registers    -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_fabric_rx_transfer_clk.reg]
  set aib_fabric_pma_aib_tx_clk_col  [get_registers    -nowarn altera_xcvr_hip_channel_s10_ch${channels}|altera_xcvr_pcie_hip_channel_s10_ch${channels}|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_fabric_pma_aib_tx_clk.reg]
  set pld_tx_clk1_dcm_reg_col        [get_registers    -nowarn g_xcvr_native_insts[*].ct1_xcvr_native_inst|ct1_xcvr_native_inst|inst_ct1_xcvr_channel|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~pld_tx_clk1_dcm.reg]


  # Cut paths for internal loopback paths when bonding is enabled
  if {[get_collection_size $pld_tx_clk2_dcm_reg_col] > 0 && [get_collection_size $aib_fabric_tx_data_lpbk_col] > 0 && [get_collection_size $aib_fabric_rx_transfer_clk_col] > 0} {
    set_false_path -from $pld_tx_clk2_dcm_reg_col -through $aib_fabric_tx_data_lpbk_col -to $aib_fabric_rx_transfer_clk_col
  }

  # Cut the paths for the internal loopback paths
  if {[get_collection_size $aib_fabric_pma_aib_tx_clk_col] > 0 && [get_collection_size $aib_fabric_tx_data_lpbk_col] > 0 && [get_collection_size $aib_fabric_rx_transfer_clk_col] > 0} {
    set_false_path -from $aib_fabric_pma_aib_tx_clk_col -through $aib_fabric_tx_data_lpbk_col -to $aib_fabric_rx_transfer_clk_col
  }
  if {[get_collection_size $pld_tx_clk1_dcm_reg_col] > 0 && [get_collection_size $aib_fabric_tx_data_lpbk_col] > 0 && [get_collection_size $aib_fabric_rx_transfer_clk_col] > 0} {
    set_false_path -from $pld_tx_clk1_dcm_reg_col -through $aib_fabric_tx_data_lpbk_col -to $aib_fabric_rx_transfer_clk_col
  }

}; # for channels


#-------------------------------------------------- #
#---                                            --- #
#--- Adjusting the min pulse width for          --- #
#--- coreclkin2 requirement to be               --- #
#--- frequency-dependent                        --- #
#---                                            --- #
#-------------------------------------------------- #
  
# Create dictionary of all the clocks and their nodes
set min_pulse_all_clocks_list [get_clock_list]
set min_pulse_all_clocks_nodes_dict [dict create]

foreach clk_name $min_pulse_all_clocks_list {
  set clk_node_col [get_clock_info -targets $clk_name]
      
  foreach_in_collection clk_node $clk_node_col {
    set clk_node_name [get_node_info -name $clk_node]
    dict set min_pulse_all_clocks_nodes_dict $clk_node_name $clk_name
  }
}

# -------------------------------------------------------------------------------
# TX coreclkin2
# -------------------------------------------------------------------------------
set tx_coreclkin2_col [get_pins -nowarn -compat altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[0].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_tx_clk2_dcm]

# Get fanins for tx_coreclkin2
if {[get_collection_size $tx_coreclkin2_col] > 0} {
  set tx_coreclkin_fanin_col [get_fanins -clock -stop_at_clocks $tx_coreclkin2_col]
      
  # Find clock name on the fanin
  if {[get_collection_size $tx_coreclkin_fanin_col]} {
      
    foreach_in_collection fanin_node $tx_coreclkin_fanin_col {
      set fanin_node_name [get_node_info -name $fanin_node]

      if {[dict exists $min_pulse_all_clocks_nodes_dict $fanin_node_name]} {
   	    set fanin_clock_name [dict get $min_pulse_all_clocks_nodes_dict $fanin_node_name]
        set_active_clocks [remove_from_collection [get_active_clocks] [get_clocks $fanin_clock_name]]

        # Adjust the min pulse width requirement based on frequency
        add_ddr_report_command "native_pcie_check_special_min_pulse_xndluca {$fanin_clock_name}"
      }
    }
  }
}



#-------------------------------------------------- #
#---                                            --- #
#--- DISABLE MIN_PULSE_WIDTH CHECK              --- #
#---                                            --- #
#-------------------------------------------------- #
# Disable min_width_pulse for TX source clocks
if {[dict exists $all_clocks_names tx_source_clks]} {
  set tx_source_clks_list [dict get $all_clocks_names tx_source_clks]
  foreach tx_src_clk $tx_source_clks_list {
    disable_min_pulse_width $tx_src_clk
  }
}

# Disable min_width_pulse for RX source clocks
if {[dict exists $all_clocks_names rx_source_clks]} {
  set rx_source_clks_list [dict get $all_clocks_names rx_source_clks]
  foreach rx_src_clk $rx_source_clks_list {
    disable_min_pulse_width $rx_src_clk
  }
}

#-------------------------------------------------- #
#---                                            --- #
#--- SET_FALSE_PATH for TX and RX BONDING       --- #
#---                                            --- #
#-------------------------------------------------- #

# Remove all paths for TX bonding signals


# Remove all paths for RX bonding signals if in PIPE mode (Native PCIe IP covers the case for PCIe)
set aib_fabric_rx_transfer_clk_col [get_registers    -nowarn altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~aib_fabric_rx_transfer_clk.reg]
set bond_rx_fifo_us_out_wren_col   [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_out_wren]
set bond_rx_fifo_ds_in_wren_col    [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_in_wren]
set bond_rx_fifo_ds_out_wren_col   [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_out_wren]
set bond_rx_fifo_us_in_wren_col    [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_in_wren]

set pld_rx_clk_dcm_reg_col       [get_registers    -nowarn altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx~pld_rx_clk*_dcm.reg]
set bond_rx_fifo_us_out_rden_col [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_out_rden]
set bond_rx_fifo_ds_in_rden_col  [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_in_rden]
set bond_rx_fifo_ds_out_rden_col [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_ds_out_rden]
set bond_rx_fifo_us_in_rden_col  [get_pins -compat -nowarn altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].${native_phy_tile_nodes}|gen_ct1_hssi_pldadapt_rx.inst_ct1_hssi_pldadapt_rx|bond_rx_fifo_us_in_rden]

if {[get_collection_size $aib_fabric_rx_transfer_clk_col] > 0 &&  [get_collection_size $bond_rx_fifo_us_out_wren_col] > 0 && [get_collection_size $bond_rx_fifo_ds_in_wren_col] > 0} {    
  set_false_path -from $aib_fabric_rx_transfer_clk_col -through $bond_rx_fifo_us_out_wren_col -through $bond_rx_fifo_ds_in_wren_col -to $aib_fabric_rx_transfer_clk_col
}

if {[get_collection_size $aib_fabric_rx_transfer_clk_col] > 0 &&  [get_collection_size $bond_rx_fifo_ds_out_wren_col] > 0 && [get_collection_size $bond_rx_fifo_us_in_wren_col] > 0} {    
  set_false_path -from $aib_fabric_rx_transfer_clk_col -through $bond_rx_fifo_ds_out_wren_col -through $bond_rx_fifo_us_in_wren_col -to $aib_fabric_rx_transfer_clk_col
}

if {[get_collection_size $pld_rx_clk_dcm_reg_col] > 0 &&  [get_collection_size $bond_rx_fifo_us_out_rden_col] > 0 && [get_collection_size $bond_rx_fifo_ds_in_rden_col] > 0} {    
  set_false_path -from $pld_rx_clk_dcm_reg_col  -through $bond_rx_fifo_us_out_rden_col -through $bond_rx_fifo_ds_in_rden_col -to $pld_rx_clk_dcm_reg_col
}

if {[get_collection_size $pld_rx_clk_dcm_reg_col] > 0 &&  [get_collection_size $bond_rx_fifo_ds_out_rden_col] > 0 && [get_collection_size $bond_rx_fifo_us_in_rden_col] > 0} {    
  set_false_path -from  $pld_rx_clk_dcm_reg_col -through $bond_rx_fifo_ds_out_rden_col -through $bond_rx_fifo_us_in_rden_col -to $pld_rx_clk_dcm_reg_col
}

#--------------------------------------------- #
#---                                       --- #
#--- SET_FALSE_PATH to reset synchronizers --- #
#---                                       --- #
#--------------------------------------------- #
set reset_synchronizer_pins {
  altera_xcvr_pcie_hip_native_tx_aib_reset_seq|reset_synchronizers|resync_chains[*].synchronizer_nocut|din_s1
  altera_xcvr_pcie_hip_native_tx_aib_reset_seq|transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|din_s1
  altera_xcvr_pcie_hip_native_rx_aib_reset_seq|reset_synchronizers|resync_chains[*].synchronizer_nocut|din_s1
  altera_xcvr_pcie_hip_native_rx_aib_reset_seq|transfer_ready_synchronizers|resync_chains[*].synchronizer_nocut|din_s1
}

foreach reset_reg $reset_synchronizer_pins {
  set synch_reg [get_registers -nowarn $reset_reg]
  if { [get_collection_size $synch_reg ] > 0 } {
    set_false_path -to $synch_reg
  }
}

# -------------------------------------------------------------------------------------------------- #
# --- set false path for adjacent channel connections introduced by clock skew control modeling  --- #
# -------------------------------------------------------------------------------------------------- #
set aib_tx_internal_div_reg_nodes   altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~aib_tx_internal_div.reg
set aib_fabric_transfer_clk_nodes   altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts[*].ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx~*aib_fabric_tx_transfer_clk.reg
set_false_path -from $aib_tx_internal_div_reg_nodes -to $aib_fabric_transfer_clk_nodes


#-------------------------------------------------- #
#---                                            --- #
#--- DISABLE MIN_PULSE_WIDTH CHECK on fPLL      --- #
#---                                            --- #
#-------------------------------------------------- #

# Disable min_width_pulse for fPLL counter nodes
set all_ports_list [get_ports *]
foreach_in_collection port $all_ports_list {

  set fpll_counter_nodes_list [get_nodes -nowarn [get_node_info -name $port]~inputFITTER_INSERTED_FITTER_INSERTED~fpll_c?_div]

  if {[get_collection_size $fpll_counter_nodes_list] > 0} {
    foreach_in_collection fpll_counter_node $fpll_counter_nodes_list {
      disable_min_pulse_width [get_node_info -name $fpll_counter_node]
    }
  }
}

msg_vdebug "IP SDC: End of PCIe Native PHY IP SDC file!"

# ----------------------------------------------------------------------------- #
# ---                                                                       --- #
# --- Procedure to adjust min pulse requirement for coreclkin2 to be        --- #
# --- frequency-dependency                                                  --- #
# ---                                                                       --- #
# ----------------------------------------------------------------------------- #
proc native_pcie_check_special_min_pulse_xndluca { clock_name } {
  set pass 1  

  # Find old active clocks, and then set all clocks active
  set old_active_clocks [get_active_clocks]
  set_active_clocks [all_clocks]
  
  set clock_spec_collection [get_clocks $clock_name]
  foreach_in_collection clock_spec $clock_spec_collection { }

  # Get clock period
  set period [get_clock_info -period $clock_spec]
  set frequency [expr 1 / $period * 1000]
  
  # Determine min pulse adjustment
  set frequency_list [list 0.0         501.0              600.0                 700.0                 800.0                 900.0                1000.0]
  set min_pulse_list [list 0.0 [expr 400.0-400.0] [expr 400.0 - 366.7]  [expr 400.0 - 342.9] [expr 400.0 - 325.0]  [expr 400.0 - 311.1] [expr 400.0 - 300.0] ]
  
  # Determine min pulse spec adjustment
  set i 0
  set min_pulse_adjustment 0.0 
  foreach xfreq $frequency_list {
     if { $frequency <= $xfreq } {
        set min_pulse_adjustment [lindex $min_pulse_list [expr $i - 1]]
        break
     }
     incr i
  }
  
  # Get min pulse information
  set min_pulse_info [get_min_pulse_width $clock_name]
  set min_pulse_slack [lindex [lindex $min_pulse_info 0] 0]

  # If after the adjusment we are still negative, then output the min pulse report, and indicate the failure
  if {[expr $min_pulse_slack + $min_pulse_adjustment] < 0 } {
     report_min_pulse_width -nworst 100 -detail full_path -panel_name "Minimum Pulse Width: $clock_name" [get_clocks $clock_name]
     post_message -type critical_warning "Min Pulse Requirements on Tile Transfer not met; see DDR report for more details"
     set pass 0
  }

  # Also make sure, nothing else is connected on this clock domain
  set setup_from_paths_col    [get_timing_paths -from $clock_spec -setup]
  set setup_to_paths_col      [get_timing_paths -to   $clock_spec -setup]
  set hold_from_paths_col     [get_timing_paths -from $clock_spec -hold]
  set hold_to_paths_col       [get_timing_paths -to   $clock_spec -hold]
  set recovery_from_paths_col [get_timing_paths -from $clock_spec -recovery]
  set recovery_to_paths_col   [get_timing_paths -to   $clock_spec -recovery]
  set removal_from_paths_col  [get_timing_paths -from $clock_spec -removal]
  set removal_to_paths_col    [get_timing_paths -to   $clock_spec -removal]

  set num_setup_from_paths    [get_collection_size $setup_from_paths_col]
  set num_setup_to_paths      [get_collection_size $setup_to_paths_col]
  set num_hold_from_paths     [get_collection_size $hold_from_paths_col]
  set num_hold_to_paths       [get_collection_size $hold_to_paths_col]
  set num_recovery_from_paths [get_collection_size $recovery_from_paths_col]
  set num_recovery_to_paths   [get_collection_size $recovery_to_paths_col]
  set num_removal_from_paths  [get_collection_size $removal_from_paths_col]
  set num_removal_to_paths    [get_collection_size $removal_to_paths_col]


  if {($num_setup_from_paths > 0) || ($num_setup_to_paths > 0) || ($num_hold_from_paths > 0) || ($num_hold_to_paths > 0) || ($num_recovery_from_paths > 0) || ($num_recovery_to_paths > 0) || ($num_removal_from_paths > 0) || ($num_removal_to_paths > 0)} {
     set pass 1

     # ----------------------------------------------------
     # Print out path information for SETUP FROM paths
     # ----------------------------------------------------
     if { $num_setup_from_paths > 0 } {

       # Initialize the number of found bond fifo paths from zero
       set num_bond_fifo_setup_paths 0

       foreach_in_collection path $setup_from_paths_col {

         # Check the arrival path points to see if one of them is the one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_setup_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo setup paths
               incr found_bond_fifo_setup_path
               incr num_bond_fifo_setup_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_setup_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed setup path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in setup_from_paths_col

       # If the number of bond_fifo paths found matches the number of setup paths, then we can ignore the transfers
       if { $num_bond_fifo_setup_paths != $num_setup_from_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for SETUP TO paths
     # ----------------------------------------------------
     if { $num_setup_to_paths > 0 } {

       # Initialize the number of found bond fifo paths to zero
       set num_bond_fifo_setup_paths 0

       foreach_in_collection path $setup_to_paths_col {

         # Check the arrival path points to see if one of them is one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_setup_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo setup paths
               incr found_bond_fifo_setup_path
               incr num_bond_fifo_setup_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_setup_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed setup path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in setup_to_paths_col

       # If the number of bond_fifo paths found matches the number of setup paths, then we can ignore the transfers
       if { $num_bond_fifo_setup_paths != $num_setup_to_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for HOLD FROM paths
     # ----------------------------------------------------
     if { $num_hold_from_paths > 0 } {

       # Initialize the number of found bond fifo paths from zero
       set num_bond_fifo_hold_paths 0

       foreach_in_collection path $hold_from_paths_col {

         # Check the arrival path points to see if one of them is the one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_hold_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo hold paths
               incr found_bond_fifo_hold_path
               incr num_bond_fifo_hold_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_hold_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed hold path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in hold_from_paths_col

       # If the number of bond_fifo paths found matches the number of hold paths, then we can ignore the transfers
       if { $num_bond_fifo_hold_paths != $num_hold_from_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for HOLD TO paths
     # ----------------------------------------------------
     if { $num_hold_to_paths > 0 } {

       # Initialize the number of found bond fifo paths to zero
       set num_bond_fifo_hold_paths 0

       foreach_in_collection path $hold_to_paths_col {

         # Check the arrival path points to see if one of them is one of the bond_fifo pins (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_bond_fifo_hold_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set ds_out_rden_pin_regex "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_rden"
             set us_out_rden_pin_regex "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_rden"
             set ds_out_dv_pin_regex   "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_ds_out_dv"
             set us_out_dv_pin_regex   "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|bond_tx_fifo_us_out_dv"


             if { [string match $ds_out_rden_pin_regex $pt_node_name] || [string match $us_out_rden_pin_regex $pt_node_name] || [string match $ds_out_dv_pin_regex $pt_node_name] || [string match $us_out_dv_pin_regex $pt_node_name] } {
               # Increment the number of found bond_fifo hold paths
               incr found_bond_fifo_hold_path
               incr num_bond_fifo_hold_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Print out the path info if no bond_fifo path was found
         if { $found_bond_fifo_hold_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed hold path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in hold_to_paths_col

       # If the number of bond_fifo paths found matches the number of hold paths, then we can ignore the transfers
       if { $num_bond_fifo_hold_paths != $num_hold_to_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for RECOVERY FROM paths
     # ----------------------------------------------------
     if { $num_recovery_from_paths > 0 } {
       foreach_in_collection path $recovery_from_paths_col {
         set source_node [get_node_info  -name [get_path_info -from $path]]
         set dest_node   [get_node_info  -name [get_path_info -to $path]]
         set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
         set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
         post_message -type critical_warning "Unexpected timed recovery path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
       }

       # Set pass to zero
			 set pass 0

     }

     # ----------------------------------------------------
     # Print out path information for REMOVAL FROM paths
     # ----------------------------------------------------
     if { $num_removal_from_paths > 0 } {
       foreach_in_collection path $removal_from_paths_col {
         set source_node [get_node_info -name [get_path_info -from $path]]
         set dest_node   [get_node_info -name [get_path_info -to $path]]
         set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
         set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
         post_message -type critical_warning "Unexpected timed removal path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
       }

       # Set pass to zero
			 set pass 0

     }

     # ----------------------------------------------------
     # Print out path information for RECOVERY TO paths
     # ----------------------------------------------------
     if { $num_recovery_to_paths > 0 } {

       # Initialize the number of found reset paths to zero
       set num_reset_recovery_paths 0

       foreach_in_collection path $recovery_to_paths_col {

         # Check the arrival path points to see if one of them is the reset pin (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_reset_recovery_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set reset_pin_regex "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n"

             if {[string match $reset_pin_regex $pt_node_name]} {
               # Increment the number of found reset recovery paths
               incr found_reset_recovery_path
               incr num_reset_recovery_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Print out the path info if no reset path was found
         if { $found_reset_recovery_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed recovery path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in recovery_to_paths_col

       # If the number of reset paths found matches the number of recovery paths, then we can ignore the transfers
       if { $num_reset_recovery_paths != $num_recovery_to_paths } {
         set pass 0
       }
     }

     # ----------------------------------------------------
     # Print out path information for REMOVAL TO paths
     # ----------------------------------------------------
     if { $num_removal_to_paths > 0 } {

       # Initialize the number of found reset paths to zero
       set num_reset_removal_paths 0

       foreach_in_collection path $removal_to_paths_col {

         # Check the arrival path points to see if one of them is the reset pin (we should ignore this transfer)
         set arrival_pts_col [get_path_info -arrival_points $path]
         set found_reset_removal_path 0

         foreach_in_collection point $arrival_pts_col {

           # Only check the node points
           set pt_node_id [get_point_info -node $point]

           if { $pt_node_id != "" } {
             set pt_node_name [get_node_info -name $pt_node_id]
             set reset_pin_regex "*altera_xcvr_hip_channel_s10_ch*|altera_xcvr_pcie_hip_channel_s10_ch*|g_xcvr_native_insts*.ct2_xcvr_native_inst|inst_ct2_xcvr_channel_multi|gen_rev.ct2_xcvr_channel_inst|gen_ct1_hssi_pldadapt_tx.inst_ct1_hssi_pldadapt_tx|pld_adapter_tx_pld_rst_n"


             if {[string match $reset_pin_regex $pt_node_name]} {
               # Increment the number of found reset recovery paths
               incr found_reset_removal_path
               incr num_reset_removal_paths
               break
             }

           }
         }; #foreach point in arrival_pts_col

         # Print out the path info if no reset path was found
         if { $found_reset_removal_path == 0 } {
           set source_node [get_node_info  -name [get_path_info -from $path]]
           set dest_node   [get_node_info  -name [get_path_info -to $path]]
           set source_clk  [get_clock_info -name [get_path_info -from_clock $path]]
           set dest_clk    [get_clock_info -name [get_path_info -to_clock $path]]
           post_message -type critical_warning "Unexpected timed removal path
    From: $source_node
    To: $dest_node
    Source Clock: $source_clk
    Destination Clock: $dest_clk"
         }
       }; #foreach path in removal_to_paths_col

       # If the number of reset paths found matches the number of removal paths, then we can ignore the transfers
       if { $num_reset_removal_paths != $num_removal_to_paths } {
         set pass 0
       }
    }

  }; #if { num_setup_from_paths > 0 || ... || ... }
  
  # Check if min pulse width passed
  if { $pass == 0 } {
     post_message -type critical_warning "Timing requirements not met"
  }
  
  # Before returning set the active clocks to the ones that were active before entering this function 
  set_active_clocks $old_active_clocks 
}


 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 8 qsys_top 26 qsys_top_avmm_bridge_512_0 20 avmm_bridge_512_2020 5 synth 31 altera_pcie_s10_gen3x16_512.sdc 28159 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.




proc apply_cdc {from_keep to_keep} {
if {[llength [query_collection -report -all $from_keep]] > 0 && [llength [query_collection -report -all $to_keep]] > 0} {
set_max_skew -from $from_keep -to $to_keep -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from $from_keep -to $to_keep -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.85
}
set_max_delay -from $from_keep -to $to_keep 50
set_min_delay -from $from_keep -to $to_keep -50}
}

proc apply_cdc_to_bit {to_keep} {
  if {[llength [query_collection -report -all $to_keep]] > 0} {
    set_max_delay -to $to_keep 50
    set_min_delay -to $to_keep -50
    set fanins [get_fanins -no_logic to_keep]
    foreach_in_collection fanins $fanins {
      if {[llength [query_collection -report -all $fanins]] > 0 && [llength [query_collection -report -all $to_keep]] > 0} {
        if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
            set_net_delay -from $fanins -to $to_keep -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
        }
      }
    }
  }
}

proc apply_cdc_from_bit {from_keep} {
  set_max_delay -from $from_keep 50
  set_min_delay -from $from_keep -50
  set fanouts [get_fanouts -no_logic from_keep]
  foreach_in_collection fanouts $fanouts {
    if {[llength [query_collection -report -all $fanouts]] > 0} {
      if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
          set_net_delay -from $from_keep -to $fanouts -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
      }
    }
  }  
}

# Set max skew between the gray code pointers of TX_ST fifos.
set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_tx_st_if|tx_fifo_lo|*gx0|din_gry*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_tx_st_if|tx_fifo_lo|*gx0|u_din_gry_sync|sync_regs_s1*]
apply_cdc $from_keep $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_tx_st_if|tx_fifo_hi|*gx0|din_gry*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_tx_st_if|tx_fifo_hi|*gx0|u_din_gry_sync|sync_regs_s1*]
apply_cdc $from_keep $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_tx_st_if|tx_fifo_lo|*gx1|din_gry*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_tx_st_if|tx_fifo_lo|*gx1|u_din_gry_sync|sync_regs_s1*]
apply_cdc $from_keep $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_tx_st_if|tx_fifo_hi|*gx1|din_gry*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_tx_st_if|tx_fifo_hi|*gx1|u_din_gry_sync|sync_regs_s1*]
apply_cdc $from_keep $to_keep

##########################################################################################################################################

# Set max skew between the gray code pointers of RX_ST fifo.
set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_rx_st_if|rx_fifo|*gx0|din_gry*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_rx_st_if|rx_fifo|*gx0|u_din_gry_sync|sync_regs_s1*]
apply_cdc $from_keep $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_rx_st_if|rx_fifo|*gx1|din_gry*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_rx_st_if|rx_fifo|*gx1|u_din_gry_sync|sync_regs_s1*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers *altera_pcie_s10_gen3x16_adapter_inst|u_rx_st_if|rx_st_ready*]
apply_cdc_to_bit $to_keep

##########################################################################################################################################


# Set CDC constrains between the header sync bits of Error Interface.
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_err_if|u_header_present_sync|sync_regs_s1*]

apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn  *altera_pcie_s10_gen3x16_adapter_inst|u_err_if|u_rx_par_err_sync|u_din_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_err_if|u_rx_par_err_sync|u_dout_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_err_if|u_tx_par_err_sync|u_din_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_err_if|u_tx_par_err_sync|u_dout_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_err_if|u_serr_out_sync|u_din_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_err_if|u_serr_out_sync|u_dout_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_err_if|app_err*_q1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_err_if|app_err*_q2*]
apply_cdc_to_bit $to_keep

##########################################################################################################################################

# Set max delay between the valid sync bits of FLR Interface.
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_flr_if|u_free_valid_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_flr_if|u_pf_done_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_flr_if|u_free_active_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_flr_if|u_pf_active_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_flr_if|fifo_rdata*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_flr_if|done*_q*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_flr_if|done_tdm*_q*]
apply_cdc_to_bit $to_keep

##########################################################################################################################################

# Set max delay between the valid sync bits of CFG Interface.
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_cfg_if|u_free_valid_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_cfg_if|fifo_rdata*]
apply_cdc_to_bit $to_keep

##########################################################################################################################################

#False path between iopll_locked and its registered signal.
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|rst_n_clk250_reg*]
set_false_path -to $to_keep

#False path between iopll_locked and its registered signal.
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|rst_n_reg*]
set_false_path -to $to_keep

set to_keep [get_keepers *altera_pcie_s10_gen3x16_adapter_inst|rst_n_tree_clk250_reg_s*]
set_false_path -to $to_keep


##########################################################################################################################################


# Set max skew between the Credit Interface buses that cross the outclk0 and ch0 clocks.
set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_nph_cdts_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_nph_cdts_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_nph_cdts_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_nph_cdts_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_npd_cdts_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_npd_cdts_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_npd_cdts_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_npd_cdts_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_ph_cdts_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_ph_cdts_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_ph_cdts_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_ph_cdts_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_pd_cdts_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_pd_cdts_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_pd_cdts_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_pd_cdts_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_cplh_cdts_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_cplh_cdts_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_cplh_cdts_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_cplh_cdts_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_cpld_cdts_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_cpld_cdts_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_cpld_cdts_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|u_tx_cpld_cdts_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

##########################################################################################################################################
#Constrain the signals from misc_if

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_ceb_req_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_link_req_rst_n_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_serdes_pll_locked_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pld_clk_inuse_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_link_up_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pm_linkst_in_l1_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pm_linkst_in_l0s_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_app_msi_ack_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_app_msi_req_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_app_int_sts_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pld_warm_rst_rdy_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pld_core_ready_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_app_xfer_pending_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_app_int_sts_pf1_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_apps_pm_xmt_turnoff_sync|u_din_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_apps_pm_xmt_turnoff_sync|u_dout_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_app_init_rst_sync|u_din_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_app_init_rst_sync|u_dout_sync|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_pf1_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_pf1_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_pf1_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_pf1_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pm_dstate_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pm_dstate_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pm_dstate_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pm_dstate_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pm_state_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pm_state_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pm_state_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_pm_state_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_lane_act_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_lane_act_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_lane_act_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_lane_act_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_currentspeed_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_currentspeed_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_currentspeed_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_currentspeed_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_ltssmstate_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_ltssmstate_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_ltssmstate_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_ltssmstate_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_common_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_common_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_common_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_common_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_sync*data_in_d0*]
set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_sync*data_out*]
apply_cdc $from_keep $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_sync|u_req_rd_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_misc_if|u_int_status_sync|u_ack_wr_clk|sync_regs_s1*]
apply_cdc_to_bit $to_keep

##########################################################################################################################################
# Apply cdc constraints to reset
set to_keep [get_keepers *reset_status_250sync|din_s1*]
apply_cdc_to_bit $to_keep
set_false_path -from [get_keepers *altera_avst512_iopll|altera_ep_g3x16_avst512_io_pll_s10|*] -to [get_keepers *reset_status_250sync|dreg*]
set from_keeper_collection [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|rst_n_tree_reg*]
set to_keeper_collection [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|cdts_fifo*]
if {[llength [query_collection -report -all $from_keeper_collection]] > 0 && [llength [query_collection -report -all $to_keeper_collection]] > 0} {
  set_false_path -from [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|rst_n_tree_reg*] -to [get_keepers -nowarn *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|cdts_fifo*]
}

##########################################################################################################################################
# SRIOV bridge sdc
set keeper_collection [get_keepers -nowarn *ceb_req_sync*first_stage_reg]
if {[llength [query_collection -report -all $keeper_collection]] > 0} {
  set_false_path -to [get_keepers -nowarn *ceb_req_sync*first_stage_reg]
}
set keeper_collection [get_keepers -nowarn *status_update_sync*first_stage_reg]
if {[llength [query_collection -report -all $keeper_collection]] > 0} {
  set_false_path -to [get_keepers -nowarn *status_update_sync*first_stage_reg]
}
set keeper_collection [get_keepers -nowarn *update_ack_sync*first_stage_reg]
if {[llength [query_collection -report -all $keeper_collection]] > 0} {
  set_false_path -to [get_keepers -nowarn *update_ack_sync*first_stage_reg]
}
set keeper_collection [get_keepers -nowarn *flr_cdc*flr_pf_done_500mhz_firstreg[*]]
if {[llength [query_collection -report -all $keeper_collection]] > 0} {
  set_false_path -to [get_keepers -nowarn *flr_cdc*flr_pf_done_500mhz_firstreg[*]]
}
set to_keep [get_keepers -nowarn *ceb_cdc*ceb_*_500mhz_reg*]
apply_cdc_to_bit $to_keep
set to_keep [get_keepers -nowarn *ceb_ack_sync*first_stage_reg]
apply_cdc_to_bit $to_keep
set to_keep [get_keepers -nowarn *status_update_sync*first_stage_reg]
apply_cdc_to_bit $to_keep
set to_keep [get_keepers -nowarn *cpl_pending_status_cdc*vf_trans_pending_status_250mhz_reg]
apply_cdc_to_bit $to_keep
set to_keep [get_keepers -nowarn *cpl_pending_status_cdc*vf_trans_pending_status_vfi_250mhz_reg[*]]
apply_cdc_to_bit $to_keep
set to_keep [get_keepers -nowarn *update_ack_sync*first_stage_reg]
apply_cdc_to_bit $to_keep
set to_keep [get_keepers -nowarn *flr_set_sync*first_stage_reg]
apply_cdc_to_bit $to_keep
set to_keep [get_keepers -nowarn *flr_cdc*flr_vf_set_num_500mhz_reg[*]]
apply_cdc_to_bit $to_keep
set to_keep [get_keepers -nowarn *flr_cdc*flr_pf_done_500mhz_firstreg[*]]
apply_cdc_to_bit $to_keep
set to_keep [get_keepers -nowarn *flr_cdc*flr_vf_set_vf_num_500mhz_reg[*]]
apply_cdc_to_bit $to_keep
set to_keep [get_keepers -nowarn *flr_cdc*flr_vf_set_pf_num_500mhz_reg[*]]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *ceb_cdc*heldconstantin250mhz_reg[*]]
if {[llength [query_collection -report -all $from_keep]] > 0} {
  foreach_in_collection from_keep $from_keep {
    #set node_name [get_node_info -name $from_keep]
    #set from_keep [get_keepers $node_name]
    apply_cdc_from_bit $from_keep
  }
}
##########################################################################################################################################
#CDC for the DMA IP

set from_keep [get_keepers *cdt_converter|*buf_lim*]
if {[llength [query_collection -report -all $from_keep]] > 0} {
  foreach_in_collection from_keep $from_keep {
    #set node_name [get_node_info -name $from_keep]
    #set from_keep [get_keepers $node_name]
    apply_cdc_from_bit $from_keep
  }
}

set from_keep [get_keepers *altera_pcie_s10_hip_ast_pipen1b_inst|*mps*]
if {[llength [query_collection -report -all $from_keep]] > 0} {
  foreach_in_collection from_keep $from_keep {
    #set node_name [get_node_info -name $from_keep]
    #set from_keep [get_keepers $node_name]
    apply_cdc_from_bit $from_keep
  }
}

set from_keep [get_keepers *altera_pcie_s10_hip_ast_pipen1b_inst|*mrs*]
if {[llength [query_collection -report -all $from_keep]] > 0} {
  foreach_in_collection from_keep $from_keep {
    #set node_name [get_node_info -name $from_keep]
    #set from_keep [get_keepers $node_name]
    apply_cdc_from_bit $from_keep
  }
}

##########################################################################################################################################
#CDC for cdts_fifo
proc apply_sdc_dcfifo {hier_path} {
# gray_rdptr
apply_sdc_dcfifo_rdptr $hier_path
# gray_wrptr
apply_sdc_dcfifo_wrptr $hier_path
}
#
# common constraint setting proc
#
proc apply_sdc_dcfifo_for_ptrs {from_node_list to_node_list} {
# control skew for bits
set_max_skew -from $from_node_list -to $to_node_list -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8
# path delay (exception for net delay)
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from $from_node_list -to $to_node_list -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
}
#relax setup and hold calculation
set_max_delay -from $from_node_list -to $to_node_list 100
set_min_delay -from $from_node_list -to $to_node_list -100
}
#
# mstable propgation delay
#
proc apply_sdc_dcfifo_mstable_delay {from_node_list to_node_list} {
# mstable delay
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from $from_node_list -to $to_node_list -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
}
}
#
# rdptr constraints
#
proc apply_sdc_dcfifo_rdptr {hier_path} {
# get from and to list
set from_node_list [get_keepers -nowarn $hier_path|auto_generated|*rdptr_g*]
set to_node_list [get_keepers -nowarn $hier_path|auto_generated|ws_dgrp|dffpipe*|dffe*]
if {[llength [query_collection -report -all $from_node_list]] > 0 && [llength [query_collection -report -all $to_node_list]] > 0} {
  apply_sdc_dcfifo_for_ptrs $from_node_list $to_node_list
}
# mstable
set from_node_mstable_list [get_keepers -nowarn $hier_path|auto_generated|ws_dgrp|dffpipe*|dffe*]
set to_node_mstable_list [get_keepers -nowarn $hier_path|auto_generated|ws_dgrp|dffpipe*|dffe*]
if {[llength [query_collection -report -all $from_node_mstable_list]] > 0 && [llength [query_collection -report -all $to_node_mstable_list]] > 0} {
  apply_sdc_dcfifo_mstable_delay $from_node_mstable_list $to_node_mstable_list
}
}
#
# wrptr constraints
#
proc apply_sdc_dcfifo_wrptr {hier_path} {
# control skew for bits
set from_node_list [get_keepers -nowarn $hier_path|auto_generated|delayed_wrptr_g*]
set to_node_list [get_keepers -nowarn $hier_path|auto_generated|rs_dgwp|dffpipe*|dffe*]
if {[llength [query_collection -report -all $from_node_list]] > 0 && [llength [query_collection -report -all $to_node_list]] > 0} {
  apply_sdc_dcfifo_for_ptrs $from_node_list $to_node_list
}
# mstable
set from_node_mstable_list [get_keepers -nowarn $hier_path|auto_generated|rs_dgwp|dffpipe*|dffe*]
set to_node_mstable_list [get_keepers -nowarn $hier_path|auto_generated|rs_dgwp|dffpipe*|dffe*]
if {[llength [query_collection -report -all $from_node_mstable_list]] > 0 && [llength [query_collection -report -all $to_node_mstable_list]] > 0} {
  apply_sdc_dcfifo_mstable_delay $from_node_mstable_list $to_node_mstable_list
}
}

# proc apply_sdc_pre_dcfifo {entity_name} {

# set inst_list [get_entity_instances $entity_name]

# foreach each_inst $inst_list {

        # apply_sdc_dcfifo ${each_inst} 

    # }
# }
set fifo_loc *altera_pcie_s10_gen3x16_adapter_inst|u_credit_if|cdts_fifo*
apply_sdc_dcfifo $fifo_loc

set fifo_loc *altera_pcie_s10_hip_ast_pipen1b_inst|pf_flr_snoop|dcfifo_component*
apply_sdc_dcfifo $fifo_loc
#apply_sdc_pre_dcfifo dcfifo
##########################################################################################################################################
set_max_delay -to [get_keepers -nowarn {*|flr_rcvd_sync|first_stage_reg*}] 6ns
set_max_delay -to [get_keepers -nowarn {*|pf_flr_active_reg[*]*}] 6ns
set_max_delay -to [get_keepers -nowarn {*|pf*_flr_array|pf_flr_frame_sreg*}] 6ns
set_max_delay -to [get_keepers -nowarn {*|pf*_flr_array|init_counter[*]*}] 6ns

 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 8 qsys_top 17 qsys_top_master_0 28 altera_jtag_dc_streaming_191 5 synth 35 altera_avalon_st_jtag_interface.sdc 911 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set_false_path -from [get_registers *altera_jtag_src_crosser:*|sink_data_buffer*] -to [get_registers *altera_jtag_src_crosser:*|src_data*]
 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 8 qsys_top 17 qsys_top_master_0 28 altera_reset_controller_1920 5 synth 27 altera_reset_controller.sdc 1620 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 8 qsys_top 35 qsys_top_mm_clock_crossing_bridge_0 26 altera_avalon_dc_fifo_1940 5 synth 74 qsys_top_mm_clock_crossing_bridge_0_altera_avalon_dc_fifo_1940_j7a573y.sdc 4916 #-------------------------------------------------------------------------------
# TimeQuest constraints to constrain the timing across asynchronous clock domain crossings.
# The idea is to minimize skew to less than one launch clock period to keep the gray encoding, 
# and to minimize latency on the pointer crossings.
#
# The paths are from the Gray Code read and write pointers to their respective synchronizer banks.
#
# *** Important note *** 
#
# Do not declare the FIFO clocks as asynchronous at the top level, or false path these crossings,
# because that will override these constraints.
#-------------------------------------------------------------------------------
set all_dc_fifo [get_entity_instances qsys_top_mm_clock_crossing_bridge_0_altera_avalon_dc_fifo_1940_j7a573y]

set_max_delay -from [get_registers {*|in_wr_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 200
set_min_delay -from [get_registers {*|in_wr_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] -200

set_max_delay -from [get_registers {*|out_rd_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 200
set_min_delay -from [get_registers {*|out_rd_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] -200

set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from [get_pins -compatibility_mode {*|in_wr_ptr_gray[*]*}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 
set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from [get_pins -compatibility_mode {*|out_rd_ptr_gray[*]*}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}]


foreach dc_fifo_inst $all_dc_fifo {
   if { [ llength [query_collection -report -all [get_registers -nowarn $dc_fifo_inst|in_wr_ptr_gray[*]]]] > 0  } {
      set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -from [get_registers $dc_fifo_inst|in_wr_ptr_gray[*]] -to [get_registers $dc_fifo_inst|write_crosser|sync[*].u|din_s1] 
   }

   if { [ llength [query_collection -report -all [get_registers -nowarn $dc_fifo_inst|out_rd_ptr_gray[*]]]] > 0 } {
      set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -from [get_registers $dc_fifo_inst|out_rd_ptr_gray[*]] -to [get_registers $dc_fifo_inst|read_crosser|sync[*].u|din_s1] 
   }
}


# add in timing constraints across asynchronous clock domain crossings for simple dual clock memory inference

set mem_regs [get_registers -nowarn *|qsys_top_mm_clock_crossing_bridge_0_altera_avalon_dc_fifo_1940_j7a573y:*|mem*];
if {![llength [query_collection -report -all $mem_regs]] > 0} {
    set mem_regs [get_registers -nowarn qsys_top_mm_clock_crossing_bridge_0_altera_avalon_dc_fifo_1940_j7a573y:*|mem*];
}

set internal_out_payload_regs [get_registers -nowarn *|qsys_top_mm_clock_crossing_bridge_0_altera_avalon_dc_fifo_1940_j7a573y:*|internal_out_payload*];
if {![llength [query_collection -report -all $internal_out_payload_regs]] > 0} {
    set internal_out_payload_regs [get_registers -nowarn qsys_top_mm_clock_crossing_bridge_0_altera_avalon_dc_fifo_1940_j7a573y:*|internal_out_payload*];
}

if {[llength [query_collection -report -all $internal_out_payload_regs]] > 0 && [llength [query_collection -report -all $mem_regs]] > 0} {
    set_max_delay -from $mem_regs -to $internal_out_payload_regs 200
    set_min_delay -from $mem_regs -to $internal_out_payload_regs -200

    set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from $mem_regs -to $internal_out_payload_regs

    #set_max_skew 2 -from $mem_regs -to $internal_out_payload_regs
}

# -----------------------------------------------------------------------------
# This procedure constrains the skew between the pointer bits, and should
# be called from the top level SDC, once per instance of the FIFO.
#
# The hierarchy path to the FIFO instance is required as an 
# argument.
# -----------------------------------------------------------------------------
proc constrain_altera_avalon_dc_fifo_ptr_skew { path } {

    set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -from [ get_registers $path|in_wr_ptr_gray\[*\] ] -to [ get_registers $path|write_crosser|sync\[*\].u|din_s1 ]
    set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -from [ get_registers $path|out_rd_ptr_gray\[*\] ] -to [ get_registers $path|read_crosser|sync\[*\].u|din_s1 ]

}

 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 14 system_manager 22 system_manager_iopll_0 17 altera_iopll_1931 5 synth 52 system_manager_iopll_0_altera_iopll_1931_6p7jvxa.sdc 5635 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the timing constraints for the Altera PLL.
#    * The helper routines are defined in system_manager_iopll_0_altera_iopll_1931_6p7jvxa_pin_map.tcl
#
# NOTE
# ----
# Debug switch. Change to 1 to get more run-time debug information
set debug 0

set script_dir [file dirname [info script]]

source "$script_dir/system_manager_iopll_0_altera_iopll_1931_6p7jvxa_parameters.tcl"
source "$script_dir/system_manager_iopll_0_altera_iopll_1931_6p7jvxa_pin_map.tcl"

####################
#                  #
# GENERAL SETTINGS #
#                  #
####################

# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty


# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3

# Determine if entity names are on
set entity_names_on [ ai_are_entity_names_on ]

if {[catch {load_package atoms
            load_package sdc_ext
            load_package design
            catch {read_atom_netlist} read_atom_netlist_out
            set read_atom_netlist_error [regexp "ERROR" $read_atom_netlist_out]
            } err_loading_packages]} {
    post_message -type error "Failed to load packages required by IOPLL SDC: $err_loading_packages"
}

# This is the main call to the netlist traversal routines
# that will automatically find all pins and registers required
# to apply timing constraints.
# During the fitter, the routines will be called only once
# and cached data will be used in all subsequent calls.



if {[info exists ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_ai_pll_db]} {
    # Clean-up stale content
    unset ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_ai_pll_db
}
if {[catch {ai_initialize_pll_db ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_ai_pll_db} err_initializing_db]} {
    post_message -type warning "Failed to find atom information in IOPLL SDC: $err_initializing_db"
}

# If multiple instances of this core are present in the
# design they will all be constrained through the
# following loop
set instances [ array names ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_ai_pll_db ]
foreach { inst } $instances {
	if { [ info exists pins ] } {
		# Clean-up stale content
		unset pins
	}
	
	# -------------------------------- #
	# -                              - #
	# --- Determine PLL Parameters --- #
	# -                              - #
	# -------------------------------- #
	
	set pll_atoms [get_atom_nodes -matching ${inst}* -type IOPLL]
	set num_pll_inst [get_collection_size $pll_atoms]
	
	if {$num_pll_inst > 1} { 
		# Error condition
		post_message -type error "SDC: More than one PLL atom found with instance name $inst"
	} else {
		# Use IP generated parameters
		if { $debug } {
			post_message -type info "SDC: using IP generated parameter values"
		}
	}

    # These dictionaries hold all the clock information.
    lassign $::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_ai_pll_db($inst) base_clock_data_dict gen_clock_data_dict
	
	# ------------------------ #
	# -                      - #
	# ---REFERENCE CLOCK(s)--- #
	# -                      - #
	# ------------------------ #
    dict for {clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_fpga_pin && !$exists} {
               create_clock -period $period \
                   -waveform [ list 0 $half_period] \
                   -name $name $port_node_name
            }
        }
    }
	# ------------------------- #
	# -                       - #
	# --- OUTPUT PLL CLOCKS --- #
	# -                       - #
	# ------------------------- #
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            if {$is_valid && !$exists} {
                create_generated_clock -add \
                    -source $src \
                    -name $name \
                    -multiply_by $multiply_by \
                    -divide_by $divide_by \
                    -phase $phase \
                    -duty_cycle $duty_cycle \
                    $pin_node_name
                
                if {[string match lvds* $clock_key] && [string match *loaden* $pattern] && [dict exists $gen_clock_data_dict $clock_key "through_pin" ] } {  
                    set_max_delay_in_fit_or_false_path_in_sta_through_no_warn $through_pin $max_delay
                } 
            }
        }
    }
}
 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 14 system_manager 22 system_manager_iopll_0 17 altera_iopll_1931 5 synth 63 system_manager_iopll_0_altera_iopll_1931_6p7jvxa_parameters.tcl 6374 # PLL Parameters

#USER W A R N I N G !
#USER The PLL parameters are statically defined in this
#USER file at generation time!
#USER To ensure timing constraints and timing reports are correct, when you make 
#USER any changes to the PLL component using the Qsys,
#USER apply those changes to the PLL parameters in this file

set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename system_manager_iopll_0_altera_iopll_1931_6p7jvxa

set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data [dict create]
set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data [dict create]
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk pattern __inst_name__|stratix10_altera_iopll_i|s10_iopll.fourteennm_pll|refclk\[0\]
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk node_type pin
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk pin_id ""
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk pin_node_name ""
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk port_id ""
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk port_node_name ""
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk is_fpga_pin false
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk is_main_refclk true
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk exists false
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk name "__inst_name___refclk"
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk period 20.000
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data refclk half_period 10.000
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock pattern __inst_name__|stratix10_altera_iopll_i|s10_iopll.fourteennm_pll~ncntr_reg
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock node_type register
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock pin_id ""
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock is_valid false
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock exists false
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock name "__inst_name___n_cnt_clk"
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock src refclk
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock multiply_by 1
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock divide_by 1
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock phase 0.000
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data n_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock pattern __inst_name__|stratix10_altera_iopll_i|s10_iopll.fourteennm_pll~mcntr_reg
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock node_type register
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock pin_id ""
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock is_valid false
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock exists false
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock name "__inst_name___m_cnt_clk"
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock src refclk
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock multiply_by 1
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock divide_by 28
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock phase 0.000
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data m_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 pattern __inst_name__|stratix10_altera_iopll_i|s10_iopll.fourteennm_pll|outclk\[0\]
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 node_type pin
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 pin_id ""
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 pin_node_name ""
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 is_valid false
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 exists false
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 name __inst_name___outclk0
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 src refclk
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 multiply_by 28
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 divide_by 28
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 phase -45.000
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 duty_cycle 50
dict set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data outclk0 counter_index 0
 13 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 2 ip 14 system_manager 22 system_manager_iopll_0 17 altera_iopll_1931 5 synth 60 system_manager_iopll_0_altera_iopll_1931_6p7jvxa_pin_map.tcl 37499 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the traversal routines that are used by
# system_manager_iopll_0_altera_iopll_1931_6p7jvxa.sdc scripts. 
#
# These routines are only meant to support the SDC. 
# Trying to using them in a different context can have unexpected 
# results.

set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_debug 0

set script_dir [file dirname [info script]]

source [file join $script_dir system_manager_iopll_0_altera_iopll_1931_6p7jvxa_parameters.tcl]

proc get_warnings_disabled {} {
    set local_disable_warnings true
    set inis [split [get_global_assignment -name INI_VARS] ";"]
    foreach ini $inis {
        set ini_lst [split $ini "="]
        lassign $ini_lst ini_name ini_value
        if {$ini_name == "disable_warnings" && $ini_value == "off"} {
            set local_disable_warnings false
            break
        }
    }
    return $local_disable_warnings 
}
set ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_disable_warnings [get_warnings_disabled]

# ----------------------------------------------------------------
#
proc ai_post_message {msg_type msg {msg_context sta_only}} {
#
# Description: Posts a message to Quartus, depending on 
# msg_context (sta_only, all)
#              
#              
#
# ----------------------------------------------------------------

    if {$msg_type == "debug"} {
        if {$::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_debug} {
            puts $msg
        }
    } else {
        if {$msg_context == "all"} {
            post_message -type $msg_type $msg
        } elseif {$msg_context == "sta_only"} {
            if {$::TimeQuestInfo(nameofexecutable) == "quartus_sta"} {
                post_message -type $msg_type $msg
            }
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_are_entity_names_on { } {
#
# Description: Determines if the entity names option is on
#
# ----------------------------------------------------------------
	return [set_project_mode -is_show_entity]	
}

# ----------------------------------------------------------------
#
proc ai_initialize_pll_db { pll_db_par } {
#
# Description: Gets the instances of this particular PLL IP and creates the pin
#              cache
#
# ----------------------------------------------------------------
	upvar $pll_db_par local_pll_db

	global ::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename

	ai_post_message info "Initializing PLL database for CORE $::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename"
	set instance_list [ai_get_core_instance_list $::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename]

	foreach instname $instance_list {
		ai_post_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename INSTANCE: $instname"

		set clock_data_dicts [ai_get_pll_pins $instname]
		lassign $clock_data_dicts base_clock_data_dict gen_clock_data_dict
        print_clock_data $base_clock_data_dict
        print_clock_data $gen_clock_data_dict 

		set local_pll_db($instname) $clock_data_dicts 
	}
}

# ----------------------------------------------------------------
#
proc ai_get_core_instance_list {corename} {
#
# Description: Converts node names from one style to another style
#
# ----------------------------------------------------------------
	set full_instance_list [ai_get_core_full_instance_list $corename]
	set instance_list [list]

	foreach inst $full_instance_list {
		if {[lsearch $instance_list [escape_brackets $inst]] == -1} {
            ai_post_message debug "Found instance:  $inst"
			lappend instance_list $inst
		}
	}
	return $instance_list
}

# ----------------------------------------------------------------
#
proc ai_get_core_full_instance_list {corename} {
#
# Description: Finds the instances of the particular IP by searching through the cells
#
# ----------------------------------------------------------------

	set instance_list [design::get_instances -entity $corename]
                               
	if {[ llength $instance_list ] == 0} {

        if {!$::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_disable_warnings} {
            ai_post_message warning "The auto-constraining script was not able to detect any instance for core < $corename >" all
            ai_post_message warning "Verify the following:"
            ai_post_message warning " The core < $corename > is instantiated within another component (wrapper)" all
            ai_post_message warning " The core is not the top-level of the project" all
        }
	}

	return $instance_list
}
proc ai_get_registers {pattern} {
    if {$::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_disable_warnings} {
        return [get_registers -nowarn -no_duplicates $pattern]
    } else {
        return [get_registers -no_duplicates $pattern]
    }
}
proc ai_get_pins {pattern} {
    if {$::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_corename_disable_warnings} {
        return [get_pins -nowarn -no_duplicates $pattern]
    } else {
        return [get_pins -no_duplicates $pattern]
    }
}
proc ai_get_pin_node_name {pattern} {
    set pin_collection [ai_get_pins $pattern]
    set num_pins [get_collection_size $pin_collection]
    if {$num_pins == 1} {
        foreach_in_collection id $pin_collection {
            set node_name [get_node_info -name $id]	     
            return $node_name
        }
    } 
    return ""
 
}

# ----------------------------------------------------------------
#
proc ai_get_collection_size_from_pattern {pattern} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    set pin_collection [get_pins -no_duplicates $pattern]
    return [get_collection_size $pin_collection]
}

# ----------------------------------------------------------------
#
proc print_clock_data {d} {
#
# Description: Prints clock data dict
#
# ---------------------------------------------------------------- 
    dict for {clock_key info} $d {
        ai_post_message debug "Clock:  $clock_key"
        dict for {key val} $info {
            ai_post_message debug "   $key: $val"
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_subst_instname {clock_data_dict patt} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            regsub -all "__inst_name__" $name $patt new_name
            regsub -all "__inst_name__" $pattern $patt new_pattern
            
            dict set clock_data_dict $clock_key name $new_name
            dict set clock_data_dict $clock_key pattern $new_pattern
            
            if {[dict exists $clock_data_dict $clock_key "through_pin" ]} {
                regsub -all "__inst_name__" $through_pin $patt new_through_pin
                dict set clock_data_dict $clock_key through_pin $new_through_pin
            }
        }
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_update_genclk_div_mult {clock_data_dict pll_parameters_dict} {
#
# Description: Updates the dict with div/mult values collected from
# the PLL's atom parameters.
#
# ----------------------------------------------------------------
    set compensated_counter_div 0
    set clock_to_compensate [dict get $pll_parameters_dict clock_to_compensate]
    # Loop over dict to find the compensated counter's div value first.
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {[info exists counter_index]} { 
                if {$counter_index == $clock_to_compensate} {
                    set compensated_counter_div [dict get $pll_parameters_dict c${counter_index}_total]
                }
            }
        }
        unset -nocomplain counter_index
    }
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Getting div/mult factors for clock $clock_key" 

            set ccnt -1
            if {[info exists counter_index]} {
                set ccnt [dict get $pll_parameters_dict c${counter_index}_total]
			    set ccnt_dc [dict get $pll_parameters_dict duty_cycle${counter_index}]
            } else {
                set counter_index -1
			    set ccnt_dc 50
            }
            set mult_div [ai_get_mult_div_factors \
                $clock_key \
                $src \
                [dict get $pll_parameters_dict n_total] \
                [dict get $pll_parameters_dict m_total] \
                $ccnt \
                $counter_index \
                $compensated_counter_div \
                [dict get $pll_parameters_dict compensation_mode] \
                [dict get $pll_parameters_dict clock_to_compensate]]

            lassign $mult_div mult div

            ai_post_message debug "Setting mult_div factors for: $clock_key to $mult/$div"

            dict set clock_data_dict $clock_key multiply_by $mult
            dict set clock_data_dict $clock_key divide_by $div
            dict set clock_data_dict $clock_key duty_cycle $ccnt_dc
        }
        unset -nocomplain counter_index
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_set_genclk_pin_info {clock_data_dict} {
#
# Description: Updates the dict with pin info collected from making
# STA API calls.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            if {$node_type == "register"} {
                set pin_collection [ai_get_registers $pattern]
            } elseif {$node_type == "pin"} {
                set pin_collection [ai_get_pins $pattern]
            } else {
                ai_post_message "debug" "Incorrect type of node."
            }
            set num_pins [get_collection_size $pin_collection]
            if {$num_pins == 1} {
                # Always set valid to true if we found the pin node
                ai_post_message debug "Setting clock as valid."
                dict set clock_data_dict $clock_key is_valid true
                
                # This for loop should only loop once.
                foreach_in_collection id $pin_collection {
                    set node_name [get_node_info -name $id]	     
                    dict set clock_data_dict $clock_key pin_id $id
                    dict set clock_data_dict $clock_key pin_node_name $node_name
                }
                # Check if clock_exists, if it does, then
                # set key "exists" on the clock info dict.
                dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

            
            } else {
                dict set clock_data_dict $clock_key is_valid false
            }

        }
    }
    return $clock_data_dict
    
    
} 
# ----------------------------------------------------------------
#
proc ai_set_baseclk_pin_info {clock_data_dict refclk_data_dict} {
#
    # Description: Updates the dict with pin info collected from refclk data
    # dict, which was obtained by traversing netlist.
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_set_baseclk_pin_info"

    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            
            # For each clock in refclk dict, find the one whose pin name
            # matches the pattern in baseclk dict. WE need to do this since
            # we dont find refclk nodes with patterns, but rather by traversal
            # of netlist from outclk backwards.
            
            set node_name ""
            dict for {clock_id info} $refclk_data_dict {
                dict with info {
                    ai_post_message debug "Comparing pattern $pattern with refclock: $ref_pin_node_name"
                    if {[string equal -nocase $pattern $ref_pin_node_name]} {
                        dict set clock_data_dict $clock_key pin_id $ref_pin_id
                        dict set clock_data_dict $clock_key pin_node_name $ref_pin_node_name
                        dict set clock_data_dict $clock_key port_id $ref_port_id
                        dict set clock_data_dict $clock_key port_node_name $ref_port_node_name
                        dict set clock_data_dict $clock_key is_fpga_pin $ref_is_fpga_pin
                        set node_name $ref_port_node_name
                        break
                    }
                }
            }
            # Check if clock_exists, if it does, then
            # set key "exists" on the clock info dict.
            dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

        }
    }
    return $clock_data_dict
    
}
proc ai_get_n_cnt_clock_node_name {gen_clock_data_dict} {
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Clock:  $clock_key, pin_node_name: $pin_node_name"

            if {$clock_key == "n_cnt_clock"} {
                return $pin_node_name
            }
        }
    }
    return ""
}

# ----------------------------------------------------------------
#
proc ai_update_baseclk_data {base_clock_data_dict pll_parameters_dict} {
#
    # Description: Updates the refclk information based on atom settings
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_baseclk_data_dict"

    dict for {base_clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_main_refclk} {
                set ref_period [dict get $pll_parameters_dict refclk_period]
                set ref_period [expr round($ref_period * 1000.0)/1000.0] 
                set ref_period [format %.3f $ref_period]
                dict set base_clock_data_dict $base_clock_key period $ref_period

                set half_period [expr $ref_period /2]
                set half_period [expr round($half_period * 1000.0)/1000.0] 
                set half_period [format %.3f $half_period]
                dict set base_clock_data_dict $base_clock_key half_period $half_period
            }
        }
    }

    return $base_clock_data_dict
}

# ----------------------------------------------------------------
#
proc ai_update_genclk_sources {base_clock_data_dict gen_clock_data_dict pll_parameters_dict} {
#
    # Description: Updates the genclk data dict with src nodes from the appropriate
    # refclks
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_genclk_sources"

    # Check if vcoph pin exists, if it does then set the clock source
    # as vcoph otherwise set it to either refclk or n_cnt_clock
    set vcoph_exists false
    if {[dict exists $gen_clock_data_dict vcoph]} {
        set vcoph_pin_name [ai_get_pin_node_name [dict get $gen_clock_data_dict vcoph pattern]]
        if {$vcoph_pin_name != ""} {
            ai_post_message debug "vcoph pin name: $vcoph_pin_name "
            set vcoph_exists true
        }
    }

    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Setting src pin info for clock $clock_key"

            set node_name ""
            set main_refclk_key ""
            dict for {base_clock_key info} $base_clock_data_dict {
                dict with info {
                    if {$is_main_refclk} {
                        set main_refclk_key $base_clock_key
                        if {$is_fpga_pin} {
                            set node_name $port_node_name
                        } else {
                            set node_name $pin_node_name
                        }
                        break
                    }
                }
            }
 
            if {$clock_key != "n_cnt_clock" && ![dict get $pll_parameters_dict n_bypass]} {
                set src "n_cnt_clock"
            }

            if {$src == "refclk" || $src == "cascade_in"} {
                set src_ $node_name
            } elseif {$src == "n_cnt_clock"} {
                set src_ [ai_get_n_cnt_clock_node_name $gen_clock_data_dict]
            } else {
                set src_ "" 
                ai_post_message "warning" "Undefined clock source: $src"

                dict set gen_clock_data_dict $clock_key is_valid false 
            }

            if {$clock_key != "n_cnt_clock" && $clock_key != "vcoph" && $vcoph_exists} {
                set src_ $vcoph_pin_name
            }

            dict set gen_clock_data_dict $clock_key src $src_
        }
    }
    return $gen_clock_data_dict 
    
}
proc ai_invalidate_clocks {clock_data_dict} {
    # Set the is_valid flag on each clock to false
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            dict set clock_data_dict $clock_key is_valid false
        }
    }
    return $clock_data_dict
}
proc ai_get_first_outclk_node {clock_data_dict} {
    set outclk_pin_id "None"
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {$node_type == "pin" && $is_valid} {
                set outclk_pin_id $pin_id
                break
            }
        }
    }
    if {$outclk_pin_id == "None"} {
        ai_post_message "warning" "Could not find any valid outclks"
    }
    return $outclk_pin_id 
}
# ----------------------------------------------------------------
#
proc ai_get_pll_pins { instname } {
#
# Description: Stores the pins of interest for the instance of the IP
#
# ----------------------------------------------------------------

    set base_clock_data_dict $::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_base_clock_data
    set gen_clock_data_dict $::GLOBAL_top_system_manager_iopll_0_altera_iopll_1931_6p7jvxa_gen_clock_data
    # First regsub the instance name for the pin names and patterns.
    set base_clock_data_dict [ai_subst_instname $base_clock_data_dict $instname]
    set gen_clock_data_dict [ai_subst_instname $gen_clock_data_dict $instname]


    set pll_parameters_dict [ai_get_pll_atom_parameters $instname] 
    set gen_clock_data_dict [ai_set_genclk_pin_info $gen_clock_data_dict]

    ai_post_message debug "gen_clock_data_dict initial: "
    print_clock_data $gen_clock_data_dict 
    
    # Traverse the first generated clock back to find FPGA pins for refclks.
    set outclk_node_id [ai_get_first_outclk_node $gen_clock_data_dict]
    if {$outclk_node_id != "None"} {
        set refclk_data_dict [ai_get_input_clk_info $outclk_node_id]
        ai_post_message debug "refclk_data_dict: "
        print_clock_data $refclk_data_dict

        set base_clock_data_dict [ai_set_baseclk_pin_info $base_clock_data_dict $refclk_data_dict]
        set gen_clock_data_dict [ai_update_genclk_sources $base_clock_data_dict $gen_clock_data_dict $pll_parameters_dict]
        set gen_clock_data_dict [ai_update_genclk_div_mult $gen_clock_data_dict $pll_parameters_dict] 
        set base_clock_data_dict [ai_update_baseclk_data $base_clock_data_dict $pll_parameters_dict] 
        ai_post_message debug "base_clock_data_dict: "
        print_clock_data $base_clock_data_dict 
        ai_post_message debug "gen_clock_data_dict final: "
        print_clock_data $gen_clock_data_dict
    } else {
        # Make sure that we don't create any clock constraints
        # if no output clock was found
        set gen_clock_data_dict [ai_invalidate_clocks $gen_clock_data_dict]
    }
    
    return [list $base_clock_data_dict $gen_clock_data_dict]
    
}

# ----------------------------------------------------------------
#
proc ai_get_input_clk_info { outclk_pin_id } {
#
# Description: Searches back from the output of the PLL to find the reference clock pin.
#              If the reference clock is fed by an input buffer, it finds that pin, otherwise
#              in cascading modes it will return the immediate reference clock input of the PLL.
#
# ----------------------------------------------------------------
	if {[ai_is_node_type_pll_clk $outclk_pin_id]} {
        #stores the refclk pin ids that were found by tracing the 
        #output clocks back up
		array set refclk_array [list]
		ai_traverse_fanin_up_to_depth $outclk_pin_id ai_is_node_type_pll_inclk clock refclk_array 20
        array set refclk_info_array [list]
        foreach {net_id id} [array get refclk_array] {
            set net_name [get_node_info -name $net_id]
            set refclk_info_array($net_id) $net_name

        }
        # Dict to hold the refclk info found by traversing the netlist back.
        # refclk_data = {
        #   clock_id = {
        #       ref_pin_id: str,
        #       ref_pin_node_name: str,
        #       ref_port_id: str,
        #       ref_port_node_name: str,
        #       ref_is_fpga_pin: true/false,
        #   }
        # }
        set refclk_data [dict create]
        
        set clock_id 0

        #only works if there is either 1 or 2 refclks
		if {[array size refclk_array] == 1 || [array size refclk_array] == 2} {
            #iterate over each refclk pin and trace back to find its input port
            foreach refclk_pin_id [array names refclk_info_array] {
                array set user_refclk_array [list]
                array unset refclk_array
                array unset user_refclk_array [list]
					 
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_user_clock clock user_refclk_array 5
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_pin clock refclk_array 5
					 
                # If fed by any user specified clock (which could be specified at the pin level or at the
                # buffer level), then use that pin as the source.
                # Otherwise, trace back to the dedicated input pin (depth 5 so that we don't include global clocks)
                if {[array size user_refclk_array] == 1 || [array size refclk_array] < 1} {
                    # Fed by a user specified clock, a global clock etc. 
                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id ""
                    dict set refclk_data $clock_id ref_port_node_name ""
                    dict set refclk_data $clock_id ref_is_fpga_pin false
                } else {
                    # Fed by a dedicated input pin
                    set port_id_ [lindex [array names refclk_array] 0]

                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id $port_id_
                    dict set refclk_data $clock_id ref_port_node_name [get_node_info -name $port_id_]
                    dict set refclk_data $clock_id ref_is_fpga_pin true
                }

                incr clock_id
            }
        } else {
			ai_post_message critical_warning "Could not find PLL ref clock that feeds [get_node_info -name $outclk_pin_id]" all
		}
	} else {
		ai_post_message error "Internal error: ai_get_input_clk_info only works for PLL output clocks" all
	}
	return $refclk_data
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pin { node_id } {
#
# Description: Determines if a node is a top-level port of the FPGA
#
# ----------------------------------------------------------------

	set node_type [get_node_info -type $node_id]
	if {$node_type == "port"} {
		set result 1
	} else {
		set result 0
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_user_clock { node_id } {
#
# Description: Determines if a node is a user-defined clock
#
# ----------------------------------------------------------------
    set node_name [get_node_info -name $node_id]	 
   
    if {[ai_clock_exists $node_name]} {
        return 1
    } else {
        return 0
    }
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_clk { node_id } {
#
# Description: Determines if a node is an output of a PLL
#
# ----------------------------------------------------------------

	set cell_id [get_node_info -cell $node_id]
	
	if {$cell_id == ""} {
		set result 0
	} else {
		set atom_type [get_cell_info -atom_type $cell_id]
		if {$atom_type == "IOPLL"} {
			set node_name [get_node_info -name $node_id]
            ai_post_message debug "Node_name: $node_name"
			if {[string match "*fourteennm_pll\|outclk\\\[*\\\]" $node_name]||[string match "*tennm_pll\|outclk\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll~ncntr_reg" $node_name]||[string match "*tennm_pll~ncntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll~c*cntr_reg" $node_name]||[string match "*tennm_pll~c*cntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll~mcntr_reg" $node_name]||[string match "*tennm_pll~mcntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll\|lvds_clk\\\[*\\\]" $node_name]||[string match "*tennm_pll\|lvds_clk\\\[*\\\]" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll\|loaden\\\[*\\\]" $node_name]||[string match "*tennm_pll\|loaden\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|vcoph\\\[*\\\]" $node_name]||[string match "*tennm_pll\|vcoph\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|pll_cascade_out" $node_name]||[string match "*tennm_pll\|pll_cascade_out" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|extclk_output\\\[*\\\]" $node_name]||[string match "*tennm_pll\|extclk_output\\\[*\\\]" $node_name]} {
				set result 1
			} else {
				set result 0
			}
		} else {
			set result 0
		}
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_inclk { node_id } {
#
# Description: Determines if a node is an input of a PLL
#
# ----------------------------------------------------------------


	set cell_id [get_node_info -cell $node_id]
	
	if {$cell_id == ""} {
		set result 0
	} else {
		set atom_type [get_cell_info -atom_type $cell_id]
		if {$atom_type == "IOPLL"} {
			set node_name [get_node_info -name $node_id]
			set fanin_edges [get_node_info -clock_edges $node_id]
			if {([string match "*|refclk\\\[*\\\]" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
            } elseif {([string match "*|pll_cascade_in" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
			} else {
				set result 0
			}
		} else {
			set result 0
		}
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
#
# Description: General traversal function up until a depth.  Use a function pointer to decide
#              ending conditions.
#
# ----------------------------------------------------------------

	upvar 1 $results_array_name results
	
	if {$depth < 0} {
		error "Internal error: Bad timing netlist search depth"
	}
	set fanin_edges [get_node_info -${edge_type}_edges $node_id]
	set number_of_fanin_edges [llength $fanin_edges]
	for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
		set fanin_edge [lindex $fanin_edges $i]
		set fanin_id [get_edge_info -src $fanin_edge]
		if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
			set results($fanin_id) 1
		} elseif {$depth == 0} {
		} else {
			ai_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
		}
	}
}

# ----------------------------------------------------------------
#
proc ai_index_in_collection { col j } {
#
# Description: Returns a particular index in a collection.
#              Analagous to lindex for lists.
#
# ----------------------------------------------------------------

	set i 0
	foreach_in_collection path $col {
		if {$i == $j} {
			return $path
		}
		set i [expr $i + 1]
	}
	return ""
}

#
# Description: Rounds a given floating point number
#              to 3 decimal places
#
# ----------------------------------------------------------------
proc ai_round_3dp { x } {
    return [expr { round($x * 1000) / 1000.0  } ]
}

# ----------------------------------------------------------------
# Description: Checks whether a given clock already exists 
# ----------------------------------------------------------------
proc ai_clock_exists { clock_name } {
    set clock_found false
    set input_clocks_col [get_clocks -nowarn]
    set num_input_clocks [get_collection_size $input_clocks_col]
    
    if {$num_input_clocks > 0} {
        foreach_in_collection iclk $input_clocks_col {
            if {![is_clock_defined $iclk]} {
                continue
            }

            set clk_targets_col [get_clock_info -target $iclk]
            set num_clk_targets [get_collection_size $clk_targets_col]
            if {$num_clk_targets > 0} {
                foreach_in_collection itgt $clk_targets_col {
                    set node_name [get_node_info -name $itgt]
                    if {[string compare $node_name $clock_name] == 0} {
                        set clock_found true
                        break
                    }
                }
            }
            if {$clock_found == true} {
                break;
            }
        }
    }

   return $clock_found 
}

proc ai_get_pll_atom {instname} {
    foreach_in_collection node [get_atom_nodes -type IOPLL] {
        set name [get_atom_node_info -key NAME -node $node]
        set node_list($name) $node

        if {[string first $instname $name] > -1} {
            return $node
        }
    }
    set sdc_file_name [info script]
    ai_post_message warning "Could not find IOPLL atom with the name <$instname> while processing <$sdc_file_name>. Please check the synthesis report to ensure that the IOPLL was not synthesized away." all
}
proc ai_get_mult_div_factors {clock_key src ncnt mcnt ccnt counter_index \
                              compensated_counter_div compensation_mode \
                              clock_to_compensate} {
    if {$clock_key == "vcoph"} {
        set clock_mult $mcnt
        set clock_div 1
    } elseif {$clock_key == "n_cnt_clock"} {
        set clock_mult 1
        set clock_div $ncnt
    } elseif {$clock_key == "m_cnt_clock"} {
        set clock_mult 1
        set clock_div [expr {$mcnt * $ncnt}]
    } else {

        if {[string first "vcoph" $src] > -1} {
            set clock_mult 1
            set clock_div $ccnt
        } else {
            # Handle NDFB mode. 
            # The equation for counter which is to be compensated: C_k = M / N
            # The equation for all other counters:                 C_!k = (M * C_k) / (N * C_!k)
            if {$compensation_mode == "NON_DEDICATED_SOURCE_SYNC" || $compensation_mode == "NON_DEDICATED_NORMAL"} {
                if {$counter_index == $clock_to_compensate} {
                    set clock_mult $mcnt
                    # Instead of dividing by N, we just divide by 1
                    # since a clock based on the N counter would be created
                    # if N > 1 and this clock would be derived based on that,
                    # so we already have a division happening.
                    set clock_div 1
                } else {
                    set clock_mult [expr $mcnt * $compensated_counter_div]
                    set clock_div $ccnt
                }
            } else {
                ai_post_message debug "Normal C counter"
                set clock_mult $mcnt
                set clock_div $ccnt
            }
        }
    }
    return [list $clock_mult $clock_div]

}
# ----------------------------------------------------------------
#
proc ai_get_pll_atom_parameters {instname} {
#
# Description: Gets the PLL paramaters from the Quartus atom and not 
#              from the IP generated parameters.
#
# ----------------------------------------------------------------

    set pll_atom [ai_get_pll_atom $instname]
																			 
	dict set pll_params compensation_mode [get_atom_node_info -key ENUM_IOPLL_FEEDBACK -node $pll_atom]
	dict set pll_params clock_to_compensate [get_atom_node_info -key INT_IOPLL_CLOCK_TO_COMPENSATE -node $pll_atom]

    # Get refclk frequency (might have changed since IP generation)
    set refclk_freq [get_atom_node_info -key TIME_REFERENCE_CLOCK_FREQUENCY -node $pll_atom]
    set refclk_int [string trim $refclk_freq "*MHZmhz"]
    set refclk_period [expr 1000.0 / $refclk_int]
    dict set pll_params refclk_period $refclk_period

	dict set pll_params m_hi_div [get_atom_node_info -key INT_IOPLL_M_CNT_HI_DIV -node $pll_atom]
	dict set pll_params m_lo_div [get_atom_node_info -key INT_IOPLL_M_CNT_LO_DIV -node $pll_atom]
	dict set pll_params m_bypass [get_atom_node_info -key BOOL_IOPLL_M_CNT_BYPASS_EN -node $pll_atom]
    if {[dict get $pll_params m_bypass]} {
        set total 1
    } else {
        set total  [expr [dict get $pll_params m_hi_div] + [dict get $pll_params m_lo_div]]
    }
	dict set pll_params m_total $total

	dict set pll_params n_hi_div [get_atom_node_info -key INT_IOPLL_N_CNT_HI_DIV -node $pll_atom]
	dict set pll_params n_lo_div [get_atom_node_info -key INT_IOPLL_N_CNT_LO_DIV -node $pll_atom]
	dict set pll_params n_bypass [get_atom_node_info -key BOOL_IOPLL_N_CNT_BYPASS_EN -node $pll_atom]
    if {[dict get $pll_params n_bypass]} {
        set total 1
    } else {
        set total  [expr [dict get $pll_params n_hi_div] + [dict get $pll_params n_lo_div]]
    }
	dict set pll_params n_total $total

	for { set i 0 } { $i < 9} { incr i } {
        # Get the C counter parameter settings from the atom netlist
        dict set pll_params c${i}_hi_div [get_atom_node_info -key INT_IOPLL_C_CNT_${i}_HI_DIV -node $pll_atom]
        dict set pll_params c${i}_lo_div [get_atom_node_info -key INT_IOPLL_C_CNT_${i}_LO_DIV -node $pll_atom]
        dict set pll_params c${i}_bypass [get_atom_node_info -key BOOL_IOPLL_C_CNT_${i}_BYPASS_EN -node $pll_atom]
        dict set pll_params c${i}_odd_div_duty_en [get_atom_node_info -key BOOL_IOPLL_C_CNT_${i}_EVEN_DUTY_EN -node $pll_atom]

        # Calculate the total counter value
        if {[dict get $pll_params c${i}_bypass]} {
            set total 1
        } else {
            set total [expr [dict get $pll_params c${i}_hi_div] + [dict get $pll_params c${i}_lo_div]]
        }
        dict set pll_params c${i}_total $total

        # Calculate the duty cycle
        if {[dict get $pll_params c${i}_bypass]} {
            set total_duty 50
        } else {
            if {[dict get $pll_params c${i}_odd_div_duty_en]} {
                set duty_tweak 1
            } else {
                set duty_tweak 0
            }
            set total_duty [expr (([dict get $pll_params c${i}_hi_div] - (0.5*$duty_tweak))*100)/$total]
		    set total_duty [format %.3f $total_duty]
        }
        dict set pll_params duty_cycle${i} $total_duty
    }

    return $pll_params
}

#__ACDS_USER_COMMENT__Set max delay if in fit flow, otherwise set false path through "through_pin"
# originally in the LVDS SDC. This is called if we are exporting loaden to LVDS
proc set_max_delay_in_fit_or_false_path_in_sta_through_no_warn {through_pin delay} {

    set through_pin_collection [get_pins -compatibility_mode -nowarn $through_pin]
    if {[get_collection_size $through_pin_collection] <= 0} { return }
    
    # if fit_flow == 1
    if {$::TimeQuestInfo(nameofexecutable) == "quartus_fit" } { 
        set_max_delay -through $through_pin_collection $delay
    } else { 
        set_false_path -through $through_pin_collection
    } 
} 

 11 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 8 qsys_top 45 altera_avalon_st_handshake_clock_crosser_1930 5 synth 44 altera_avalon_st_handshake_clock_crosser.sdc 7725 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#------------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Altera timing constraints for Avalon clock domain crossing (CDC) paths.
# The purpose of these constraints is to remove the false paths and replace with timing bounded 
# requirements for compilation.
#
# ***Important note *** 
#
# The clocks involved in this transfer must be kept synchronous and no false path
# should be set on these paths for these constraints to apply correctly.
# -----------------------------------------------------------------------------

set crosser_entity "altera_avalon_st_clock_crosser:"
set_max_delay -from [get_registers *${crosser_entity}*|in_data_buffer* ] -to [get_registers *${crosser_entity}*|out_data_buffer* ] 100
set_min_delay -from [get_registers *${crosser_entity}*|in_data_buffer* ] -to [get_registers *${crosser_entity}*|out_data_buffer* ] -100

set sync_entity "altera_avalon_st_clock_crosser:*|altera_std_synchronizer_nocut:"
set_max_delay -from [get_registers *${crosser_entity}* ] -to [get_registers *${sync_entity}*|din_s1 ] 100
set_min_delay -from [get_registers *${crosser_entity}* ] -to [get_registers *${sync_entity}*|din_s1 ] -100

foreach_in_collection list_of_out_data_buffers [get_registers *${crosser_entity}*|out_data_buffer* ] {
   set regname [get_register_info -name $list_of_out_data_buffers]
   set sync_path [ regsub "(.*)(out_data_buffer)(.*)" $regname "\\1" ]
   set input_data_buffer ""
   append input_data_buffer $sync_path "in_data_buffer*"
   set output_data_buffer ""
   append output_data_buffer $sync_path "out_data_buffer*"
  
   set_net_delay -from [get_registers $input_data_buffer ] -to [get_registers $output_data_buffer] -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
   set_max_skew  -from [get_registers $input_data_buffer ] -to [get_registers $output_data_buffer] -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -nowarn 
}

foreach_in_collection list_in_data_toggle [ get_registers *${crosser_entity}*|in_data_toggle ] { 
   set in_flop [ get_register_info -name $list_in_data_toggle ] 
   # replace last occurence of string
   set in_sync_path [ regsub "(.*)(in_data_toggle)" $in_flop "\\1" ]
   set in_to_out_din_s1 ""
   set in_to_out_sync_din_s1 [ get_registers -nowarn [ append in_to_out_din_s1 $in_sync_path "in_to_out_synchronizer|din_s1" ] ]
   set in_data_toggle ""
   set in_data_toggle_with_path [ get_registers -nowarn [ append in_data_toggle $in_sync_path "in_data_toggle" ] ]
   
   # check for the presence of din_s1 and set the net_delay after that
   if { [ expr { [ llength [ query_collection -report -all $in_to_out_sync_din_s1 ] ] > 0 } ] } { 
      set_net_delay -from  $in_data_toggle_with_path -to $in_to_out_sync_din_s1 -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8  
      set_max_skew  -from  $in_data_toggle_with_path -to $in_to_out_sync_din_s1 -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -nowarn
   }
} 

foreach_in_collection list_out_data_toggle_flopped [ get_registers *${crosser_entity}*|out_data_toggle_flopped ] { 
   set out_flop [ get_register_info -name $list_out_data_toggle_flopped ] 
   # replace last occurence of string
   set out_sync_path [ regsub "(.*)(out_data_toggle_flopped)" $out_flop "\\1" ]
   set out_to_in_din_s1 ""
   set out_to_in_sync_din_s1 [ get_registers -nowarn [ append out_to_in_din_s1 $out_sync_path "out_to_in_synchronizer|din_s1" ] ]
   set out_data_toggle ""
   set out_data_toggle_with_path [ get_registers -nowarn [ append out_data_toggle $out_sync_path "out_data_toggle_flopped" ] ]

   # check for the presence of din_s1 and set the net_delay after that
   if { [ expr { [ llength [ query_collection -report -all $out_to_in_sync_din_s1 ] ]  > 0 } ] } { 
      set_net_delay -from $out_data_toggle_with_path -to $out_to_in_sync_din_s1 -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8  
      set_max_skew  -from $out_data_toggle_with_path -to $out_to_in_sync_din_s1 -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -nowarn
   }
} 


# -----------------------------------------------------------------------------
# This procedure constrains the skew between the token and data bits, and should
# be called from the top level SDC, once per instance of the clock crosser.
#
# The hierarchy path to the handshake clock crosser instance is required as an 
# argument.
#
# In practice, the token and data bits tend to be placed close together, making
# excessive skew less of an issue.
# -----------------------------------------------------------------------------
proc constrain_alt_handshake_clock_crosser_skew { path } {

    set in_regs  [ get_registers $path|*altera_avalon_st_clock_crosser*|in_data_buffer* ] 
    set out_regs [ get_registers $path|*altera_avalon_st_clock_crosser*|out_data_buffer* ] 

    set in_regs [ add_to_collection $in_regs  [ get_registers $path|*altera_avalon_st_clock_crosser*|in_data_toggle ] ]
    set out_regs [ add_to_collection $out_regs [ get_registers $path|*altera_avalon_st_clock_crosser:*|altera_std_synchronizer_nocut:in_to_out_synchronizer|din_s1 ] ]

    set_max_skew -from $in_regs -to $out_regs -get_skew_value_from_clock_period dst_clock_period -skew_value_multiplier 0.8
}

 11 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 8 qsys_top 28 altera_reset_controller_1920 5 synth 27 altera_reset_controller.sdc 1620 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 11 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 14 system_manager 45 altera_avalon_st_handshake_clock_crosser_1930 5 synth 44 altera_avalon_st_handshake_clock_crosser.sdc 7725 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2018 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#------------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Altera timing constraints for Avalon clock domain crossing (CDC) paths.
# The purpose of these constraints is to remove the false paths and replace with timing bounded 
# requirements for compilation.
#
# ***Important note *** 
#
# The clocks involved in this transfer must be kept synchronous and no false path
# should be set on these paths for these constraints to apply correctly.
# -----------------------------------------------------------------------------

set crosser_entity "altera_avalon_st_clock_crosser:"
set_max_delay -from [get_registers *${crosser_entity}*|in_data_buffer* ] -to [get_registers *${crosser_entity}*|out_data_buffer* ] 100
set_min_delay -from [get_registers *${crosser_entity}*|in_data_buffer* ] -to [get_registers *${crosser_entity}*|out_data_buffer* ] -100

set sync_entity "altera_avalon_st_clock_crosser:*|altera_std_synchronizer_nocut:"
set_max_delay -from [get_registers *${crosser_entity}* ] -to [get_registers *${sync_entity}*|din_s1 ] 100
set_min_delay -from [get_registers *${crosser_entity}* ] -to [get_registers *${sync_entity}*|din_s1 ] -100

foreach_in_collection list_of_out_data_buffers [get_registers *${crosser_entity}*|out_data_buffer* ] {
   set regname [get_register_info -name $list_of_out_data_buffers]
   set sync_path [ regsub "(.*)(out_data_buffer)(.*)" $regname "\\1" ]
   set input_data_buffer ""
   append input_data_buffer $sync_path "in_data_buffer*"
   set output_data_buffer ""
   append output_data_buffer $sync_path "out_data_buffer*"
  
   set_net_delay -from [get_registers $input_data_buffer ] -to [get_registers $output_data_buffer] -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
   set_max_skew  -from [get_registers $input_data_buffer ] -to [get_registers $output_data_buffer] -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -nowarn 
}

foreach_in_collection list_in_data_toggle [ get_registers *${crosser_entity}*|in_data_toggle ] { 
   set in_flop [ get_register_info -name $list_in_data_toggle ] 
   # replace last occurence of string
   set in_sync_path [ regsub "(.*)(in_data_toggle)" $in_flop "\\1" ]
   set in_to_out_din_s1 ""
   set in_to_out_sync_din_s1 [ get_registers -nowarn [ append in_to_out_din_s1 $in_sync_path "in_to_out_synchronizer|din_s1" ] ]
   set in_data_toggle ""
   set in_data_toggle_with_path [ get_registers -nowarn [ append in_data_toggle $in_sync_path "in_data_toggle" ] ]
   
   # check for the presence of din_s1 and set the net_delay after that
   if { [ expr { [ llength [ query_collection -report -all $in_to_out_sync_din_s1 ] ] > 0 } ] } { 
      set_net_delay -from  $in_data_toggle_with_path -to $in_to_out_sync_din_s1 -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8  
      set_max_skew  -from  $in_data_toggle_with_path -to $in_to_out_sync_din_s1 -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -nowarn
   }
} 

foreach_in_collection list_out_data_toggle_flopped [ get_registers *${crosser_entity}*|out_data_toggle_flopped ] { 
   set out_flop [ get_register_info -name $list_out_data_toggle_flopped ] 
   # replace last occurence of string
   set out_sync_path [ regsub "(.*)(out_data_toggle_flopped)" $out_flop "\\1" ]
   set out_to_in_din_s1 ""
   set out_to_in_sync_din_s1 [ get_registers -nowarn [ append out_to_in_din_s1 $out_sync_path "out_to_in_synchronizer|din_s1" ] ]
   set out_data_toggle ""
   set out_data_toggle_with_path [ get_registers -nowarn [ append out_data_toggle $out_sync_path "out_data_toggle_flopped" ] ]

   # check for the presence of din_s1 and set the net_delay after that
   if { [ expr { [ llength [ query_collection -report -all $out_to_in_sync_din_s1 ] ]  > 0 } ] } { 
      set_net_delay -from $out_data_toggle_with_path -to $out_to_in_sync_din_s1 -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8  
      set_max_skew  -from $out_data_toggle_with_path -to $out_to_in_sync_din_s1 -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -nowarn
   }
} 


# -----------------------------------------------------------------------------
# This procedure constrains the skew between the token and data bits, and should
# be called from the top level SDC, once per instance of the clock crosser.
#
# The hierarchy path to the handshake clock crosser instance is required as an 
# argument.
#
# In practice, the token and data bits tend to be placed close together, making
# excessive skew less of an issue.
# -----------------------------------------------------------------------------
proc constrain_alt_handshake_clock_crosser_skew { path } {

    set in_regs  [ get_registers $path|*altera_avalon_st_clock_crosser*|in_data_buffer* ] 
    set out_regs [ get_registers $path|*altera_avalon_st_clock_crosser*|out_data_buffer* ] 

    set in_regs [ add_to_collection $in_regs  [ get_registers $path|*altera_avalon_st_clock_crosser*|in_data_toggle ] ]
    set out_regs [ add_to_collection $out_regs [ get_registers $path|*altera_avalon_st_clock_crosser:*|altera_std_synchronizer_nocut:in_to_out_synchronizer|din_s1 ] ]

    set_max_skew -from $in_regs -to $out_regs -get_skew_value_from_clock_period dst_clock_period -skew_value_multiplier 0.8
}

 11 0 1 / 4 home 9 stratix10 9 Documents 20 deep_south_interface 12 Minimum_BIST 4 qsys 14 system_manager 28 altera_reset_controller_1920 5 synth 27 altera_reset_controller.sdc 1620 # (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 0
